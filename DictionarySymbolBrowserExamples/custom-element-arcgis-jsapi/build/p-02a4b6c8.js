const t={convertToGEGeometry:function(t,i){return null==i?null:t.convertJSONToGeometry(i)},exportPoint:function(t,s,o){const n=new i(t.getPointX(s),t.getPointY(s),o),h=t.hasZ(s),r=t.hasM(s);return h&&(n.z=t.getPointZ(s)),r&&(n.m=t.getPointM(s)),n},exportPolygon:function(t,i,o){return new s(t.exportPaths(i),o,t.hasZ(i),t.hasM(i))},exportPolyline:function(t,i,s){return new o(t.exportPaths(i),s,t.hasZ(i),t.hasM(i))},exportMultipoint:function(t,i,s){return new n(t.exportPoints(i),s,t.hasZ(i),t.hasM(i))},exportExtent:function(t,i,s){const o=t.hasZ(i),n=t.hasM(i),r=new h(t.getXMin(i),t.getYMin(i),t.getXMax(i),t.getYMax(i),s);if(o){const s=t.getZExtent(i);r.zmin=s.vmin,r.zmax=s.vmax}if(n){const s=t.getMExtent(i);r.mmin=s.vmin,r.mmax=s.vmax}return r}};class i{constructor(t,i,s){this.x=t,this.y=i,this.spatialReference=s,this.z=void 0,this.m=void 0}}class s{constructor(t,i,s,o){this.rings=t,this.spatialReference=i,this.hasZ=void 0,this.hasM=void 0,s&&(this.hasZ=s),o&&(this.hasM=o)}}class o{constructor(t,i,s,o){this.paths=t,this.spatialReference=i,this.hasZ=void 0,this.hasM=void 0,s&&(this.hasZ=s),o&&(this.hasM=o)}}class n{constructor(t,i,s,o){this.points=t,this.spatialReference=i,this.hasZ=void 0,this.hasM=void 0,s&&(this.hasZ=s),o&&(this.hasM=o)}}class h{constructor(t,i,s,o,n){this.xmin=t,this.ymin=i,this.xmax=s,this.ymax=o,this.spatialReference=n,this.zmin=void 0,this.zmax=void 0,this.mmin=void 0,this.mmax=void 0}}export{t}