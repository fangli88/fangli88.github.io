import"./p-476cf7c4.js";import{y as t,dT as s,U as e}from"./p-dc4230e0.js";import"./p-643e1e47.js";import{y as i}from"./p-66f366a9.js";import"./p-ebb65ba7.js";import{i as r,Q as n}from"./p-78c83631.js";import{o as h}from"./p-725a886f.js";import{t as o}from"./p-0e87baef.js";import"./p-80a59d87.js";class a{constructor(t,s,e){this.uid=t,this.geometry=s,this.attributes=e,this.visible=!0,this.objectId=null,this.centroid=null}}class l{constructor(){this.exceededTransferLimit=!1,this.features=[],this.fields=[],this.hasM=!1,this.hasZ=!1,this.geometryType=null,this.objectIdFieldName=null,this.globalIdFieldName=null,this.geometryProperties=null,this.geohashFieldName=null,this.spatialReference=null,this.transform=null}}function u(t,s){return s}function c(t,s,e,i){switch(e){case 0:return d(t,s+i,0);case 1:return"lowerLeft"===t.originPosition?d(t,s+i,1):function({translate:t,scale:s},e,i){return t[i]-e*s[i]}(t,s+i,1)}}function p(t,s,e,i){switch(e){case 2:return d(t,s,2);default:return c(t,s,e,i)}}function f(t,s,e,i){switch(e){case 2:return d(t,s,3);default:return c(t,s,e,i)}}function y(t,s,e,i){switch(e){case 3:return d(t,s,3);default:return p(t,s,e,i)}}function d({translate:t,scale:s},e,i){return t[i]+e*s[i]}class m{constructor(t){this.options=t,this.geometryTypes=["point","multipoint","polyline","polygon"],this.previousCoordinate=[0,0],this.transform=null,this.applyTransform=u,this.lengths=[],this.currentLengthIndex=0,this.toAddInCurrentPath=0,this.vertexDimension=0,this.coordinateBuffer=null,this.coordinateBufferPtr=0,this.AttributesConstructor=function(){}}createFeatureResult(){return new l}finishFeatureResult(t){if(this.options.applyTransform&&(t.transform=null),this.AttributesConstructor=function(){},this.coordinateBuffer=null,this.lengths.length=0,!t.hasZ)return;const s=h(t.geometryType,this.options.sourceSpatialReference,t.spatialReference);if(s)for(const e of t.features)s(e.geometry)}createSpatialReference(){return new t}addField(t,s){t.fields.push(i.fromJSON(s));const e=t.fields.map((t=>t.name));this.AttributesConstructor=function(){for(const t of e)this[t]=null}}addFeature(t,s){const e=this.options.maxStringAttributeLength?this.options.maxStringAttributeLength:0;if(e>0)for(const t in s.attributes){const i=s.attributes[t];"string"==typeof i&&i.length>e&&(s.attributes[t]="")}t.features.push(s)}addQueryGeometry(t,s){const{queryGeometry:e,queryGeometryType:i}=s,h=r(e.clone(),e,!1,!1,this.transform),o=n(h,i,!1,!1);let a=null;switch(i){case"esriGeometryPoint":a="point";break;case"esriGeometryPolygon":a="polygon";break;case"esriGeometryPolyline":a="polyline";break;case"esriGeometryMultipoint":a="multipoint"}o.type=a,t.queryGeometryType=i,t.queryGeometry=o}prepareFeatures(t){switch(this.transform=t.transform,this.options.applyTransform&&t.transform&&(this.applyTransform=this.deriveApplyTransform(t)),this.vertexDimension=2,t.hasZ&&this.vertexDimension++,t.hasM&&this.vertexDimension++,t.geometryType){case"point":this.addCoordinate=(t,s,e)=>this.addCoordinatePoint(t,s,e),this.createGeometry=t=>this.createPointGeometry(t);break;case"polygon":this.addCoordinate=(t,s,e)=>this.addCoordinatePolygon(t,s,e),this.createGeometry=t=>this.createPolygonGeometry(t);break;case"polyline":this.addCoordinate=(t,s,e)=>this.addCoordinatePolyline(t,s,e),this.createGeometry=t=>this.createPolylineGeometry(t);break;case"multipoint":this.addCoordinate=(t,s,e)=>this.addCoordinateMultipoint(t,s,e),this.createGeometry=t=>this.createMultipointGeometry(t)}}createFeature(){return this.lengths.length=0,this.currentLengthIndex=0,this.previousCoordinate[0]=0,this.previousCoordinate[1]=0,this.coordinateBuffer=null,this.coordinateBufferPtr=0,new a(s(),null,new this.AttributesConstructor)}addLength(t,s,e){0===this.lengths.length&&(this.toAddInCurrentPath=s),this.lengths.push(s)}createPointGeometry(t){const s={type:"point",x:0,y:0,spatialReference:t.spatialReference,hasZ:!!t.hasZ,hasM:!!t.hasM};return s.hasZ&&(s.z=0),s.hasM&&(s.m=0),s}addCoordinatePoint(t,s,e){switch(s=this.applyTransform(this.transform,s,e,0),e){case 0:t.x=s;break;case 1:t.y=s;break;case 2:t.hasZ?t.z=s:t.m=s;break;case 3:t.m=s}}transformPathLikeValue(t,s){let e=0;return s<=1&&(e=this.previousCoordinate[s],this.previousCoordinate[s]+=t),this.applyTransform(this.transform,t,s,e)}addCoordinatePolyline(t,s,e){this.dehydratedAddPointsCoordinate(t.paths,s,e)}addCoordinatePolygon(t,s,e){this.dehydratedAddPointsCoordinate(t.rings,s,e)}addCoordinateMultipoint(t,s,e){0===e&&t.points.push([]);const i=this.transformPathLikeValue(s,e);t.points[t.points.length-1].push(i)}createPolygonGeometry(t){return{type:"polygon",rings:[[]],spatialReference:t.spatialReference,hasZ:!!t.hasZ,hasM:!!t.hasM}}createPolylineGeometry(t){return{type:"polyline",paths:[[]],spatialReference:t.spatialReference,hasZ:!!t.hasZ,hasM:!!t.hasM}}createMultipointGeometry(t){return{type:"multipoint",points:[],spatialReference:t.spatialReference,hasZ:!!t.hasZ,hasM:!!t.hasM}}dehydratedAddPointsCoordinate(t,s,e){if(null===this.coordinateBuffer){const t=this.lengths.reduce(((t,s)=>t+s),0);this.coordinateBuffer=new Float64Array(t*this.vertexDimension)}0===e&&0==this.toAddInCurrentPath--&&(t.push([]),this.toAddInCurrentPath=this.lengths[++this.currentLengthIndex]-1,this.previousCoordinate[0]=0,this.previousCoordinate[1]=0);const i=this.transformPathLikeValue(s,e);0===e&&t[t.length-1].push(new Float64Array(this.coordinateBuffer.buffer,this.coordinateBufferPtr*Float64Array.BYTES_PER_ELEMENT,this.vertexDimension)),this.coordinateBuffer[this.coordinateBufferPtr++]=i}deriveApplyTransform(t){const{hasZ:s,hasM:e}=t;return s&&e?y:s?p:e?f:c}}class w{_parseFeatureQuery(t){const s=o(t.buffer,new m(t.options)),i={...s,spatialReference:s.spatialReference.toJSON(),fields:s.fields?s.fields.map((t=>t.toJSON())):void 0};return e(i)}}function b(){return new w}export default b;