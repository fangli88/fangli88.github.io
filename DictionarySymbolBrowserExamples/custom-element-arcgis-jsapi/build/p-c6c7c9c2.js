import{p as t,a2 as e,aJ as n,Z as s,aK as o,l as r,f as i,y as c,t as f,x as a,b as l,aL as u,U as p,aM as y,aN as m,m as g,a0 as w}from"./p-ab028778.js";async function h(o,r,i,c){const f="string"==typeof o?e(o):o,a=r[0].spatialReference,l={...c,query:{...f.query,f:"json",sr:JSON.stringify(a),target:JSON.stringify({geometryType:n(r[0]),geometries:r}),cutter:JSON.stringify(i)}},u=await s(f.path+"/cut",l),{cutIndexes:p,geometries:y=[]}=u.data;return{cutIndexes:p,geometries:y.map((e=>{const n=t(e);return n.spatialReference=a,n}))}}async function x(t,r,i){const c="string"==typeof t?e(t):t,f=r[0].spatialReference,a=n(r[0]),l={...i,query:{...c.query,f:"json",sr:f.wkid?f.wkid:JSON.stringify(f),geometries:JSON.stringify((u=r,{geometryType:n(u[0]),geometries:u.map((t=>t.toJSON()))}))}};var u;return function(t,e,n){const s=o(e);return t.map((t=>{const e=s.fromJSON(t);return e.spatialReference=n,e}))}((await s(c.path+"/simplify",l)).data,a,f)}const N=r.getLogger("esri.geometry.support.normalizeUtils"),J={102100:{maxX:20037508.342788905,minX:-20037508.342788905,plus180Line:new i({paths:[[[20037508.342788905,-20037508.342788905],[20037508.342788905,20037508.342788905]]],spatialReference:c.WebMercator}),minus180Line:new i({paths:[[[-20037508.342788905,-20037508.342788905],[-20037508.342788905,20037508.342788905]]],spatialReference:c.WebMercator})},4326:{maxX:180,minX:-180,plus180Line:new i({paths:[[[180,-180],[180,180]]],spatialReference:c.WGS84}),minus180Line:new i({paths:[[[-180,-180],[-180,180]]],spatialReference:c.WGS84})}};function L(t){return"polygon"===t.type}function R(t){return"polyline"===t[0].type}function O(t){return L(t)?t.rings:t.paths}function S(t,e){return Math.ceil((t-e)/(2*e))}function M(t,e){const n=O(t);for(const t of n)for(const n of t)n[0]+=e;return t}function X(t,e,n){if(e){const e=function(t,e){if(!(t instanceof i||t instanceof a)){const t="straightLineDensify: the input geometry is neither polyline nor polygon";throw N.error(t),new g(t)}const n=O(t),s=[];for(const t of n){const n=[];s.push(n),n.push([t[0][0],t[0][1]]);for(let s=0;s<t.length-1;s++){const o=t[s][0],r=t[s][1],i=t[s+1][0],c=t[s+1][1],f=Math.sqrt((i-o)*(i-o)+(c-r)*(c-r)),a=(c-r)/f,l=(i-o)/f,u=f/e;if(u>1){for(let t=1;t<=u-1;t++){const s=t*e;n.push([l*s+o,a*s+r])}const t=(f+Math.floor(u-1)*e)/2;n.push([l*t+o,a*t+r])}n.push([i,c])}}return L(t)?new a({rings:s,spatialReference:t.spatialReference}):new i({paths:s,spatialReference:t.spatialReference})}(t,1e6);t=y(e,!0)}return n&&(t=M(t,n)),t}function b(t,e,n){if(Array.isArray(t)){const s=t[0];if(s>e){const n=S(s,e);t[0]=s+n*(-2*e)}else if(s<n){const e=S(s,n);t[0]=s+e*(-2*n)}}else{const s=t.x;if(s>e){const n=S(s,e);t=t.clone().offset(n*(-2*e),0)}else if(s<n){const e=S(s,n);t=t.clone().offset(e*(-2*n),0)}}return t}async function j(t,e,n){if(!Array.isArray(t))return j([t],e);const s=e?e.url:w.geometryServiceUrl;let o,r,c,y,g,N,L,d,q=0;const A=[],I=[];for(const e of t)if(f(e))I.push(e);else if(o||(o=e.spatialReference,r=m(o),c=o.isWebMercator,N=c?102100:4326,y=J[N].maxX,g=J[N].minX,L=J[N].plus180Line,d=J[N].minus180Line),r)if("mesh"===e.type)I.push(e);else if("point"===e.type)I.push(b(e.clone(),y,g));else if("multipoint"===e.type){const t=e.clone();t.points=t.points.map((t=>b(t,y,g))),I.push(t)}else if("extent"===e.type){const t=e.clone()._normalize(!1,!1,r);I.push(t.rings?new a(t):t)}else if(e.extent){const t=e.extent,n=S(t.xmin,g)*(2*y);let s=0===n?e.clone():M(e.clone(),n);t.offset(n,0),t.intersects(L)&&t.xmax!==y?(q=t.xmax>q?t.xmax:q,s=X(s,c),A.push(s),I.push("cut")):t.intersects(d)&&t.xmin!==g?(q=t.xmax*(2*y)>q?t.xmax*(2*y):q,s=X(s,c,360),A.push(s),I.push("cut")):I.push(s)}else I.push(e.clone());else I.push(e);let T=S(q,y),U=-90;const v=T,z=new i;for(;T>0;){const t=360*T-180;z.addPath([[t,U],[t,-1*U]]),U*=-1,T--}if(A.length>0&&v>0){const e=function(t,e){let n=-1;for(let s=0;s<e.cutIndexes.length;s++){const o=e.cutIndexes[s],r=e.geometries[s],i=O(r);for(let t=0;t<i.length;t++){const e=i[t];e.some((n=>{if(n[0]<180)return!0;{let n=0;for(let t=0;t<e.length;t++){const s=e[t][0];n=s>n?s:n}n=Number(n.toFixed(9));const s=-360*S(n,180);for(let n=0;n<e.length;n++){const e=r.getPoint(t,n);r.setPoint(t,n,e.clone().offset(s,0))}return!0}}))}if(o===n){if("polygon"===t[0].type)for(const e of O(r))t[o]=t[o].addRing(e);else if(R(t))for(const e of O(r))t[o]=t[o].addPath(e)}else n=o,t[o]=r}return t}(A,await h(s,A,z,n)),o=[],r=[];for(let n=0;n<I.length;n++){const s=I[n];if("cut"!==s)r.push(s);else{const s=e.shift(),i=t[n];l(i)&&"polygon"===i.type&&i.rings&&i.rings.length>1&&s.rings.length>=i.rings.length?(o.push(s),r.push("simplify")):r.push(c?u(s):s)}}if(!o.length)return r;const i=await x(s,o,n),f=[];for(let t=0;t<r.length;t++){const e=r[t];f.push("simplify"!==e?e:c?u(i.shift()):i.shift())}return f}const D=[];for(let t=0;t<I.length;t++){const e=I[t];if("cut"!==e)D.push(e);else{const t=A.shift();D.push(!0===c?u(t):t)}}return p(D)}export{j as P}