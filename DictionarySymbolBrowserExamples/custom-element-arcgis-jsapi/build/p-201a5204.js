import{D as e,K as t,m as r,Z as s,a4 as o,a2 as i,b as a,C as n,E as l}from"./p-ab028778.js";import{i as c}from"./p-77b9029e.js";import{a as u}from"./p-35f05b11.js";class f{constructor(e={}){this._options=e}toQueryParams(e){if(!e)return null;const t=e.toJSON(),r={};return Object.keys(t).forEach((e=>{const s=this._options[e];if(s){const o="boolean"!=typeof s&&s.name?s.name:e,i="boolean"!=typeof s&&s.getter?s.getter(t):t[e];null!=i&&(r[o]=(e=>{if(!Array.isArray(e))return!1;const[t]=e;return"number"==typeof t||"string"==typeof t})(i)?i.join(","):"object"==typeof i?JSON.stringify(i):i)}else r[e]=t[e]}),this),r}}function d(e){return new f(e)}const p=n=>{let l=class extends n{async getServiceDescription(){return this._serviceDescriptionPromise||(this._serviceDescriptionPromise=this._fetchServiceDescription()),this._serviceDescriptionPromise}async _fetchServiceDescription(){if(!this.url||!this.parsedUrl)throw new r("network-service:missing-url","Url to Network service is missing");const e=this.url,{data:t}=await s(e,{query:{f:"json"}});t.supportedTravelModes||(t.supportedTravelModes=[]);for(let e=0;e<t.supportedTravelModes.length;e++)t.supportedTravelModes[e].id||(t.supportedTravelModes[e].id=t.supportedTravelModes[e].itemId);const a=t.currentVersion>=10.4?async function(e){try{const{data:{supportedTravelModes:t,defaultTravelMode:r}}=await s(e+("/"===e[e.length-1]?"":"/")+"retrieveTravelModes",{query:{f:"json"}});return{supportedTravelModes:t,defaultTravelMode:r}}catch(e){throw new r("network-service:retrieveTravelModes","Could not get to the NAServer's retrieveTravelModes.",{error:e})}}(e):async function(e){const{data:t}=await s(e.substring(0,e.indexOf("/rest/")+6)+"info",{query:{f:"json"}});if(!t||!t.owningSystemUrl)return{supportedTravelModes:[],defaultTravelMode:null};e=t.owningSystemUrl;const{data:r}=await s(e+("/"===e[e.length-1]?"":"/")+"sharing/rest/portals/self",{query:{f:"json"}}),a=o("helperServices.routingUtilities.url",r);if(!a)return{supportedTravelModes:[],defaultTravelMode:null};const n=i(e),l=/\/solveClosestFacility$/.test(n.path)?"Route":/\/solveClosestFacility$/.test(n.path)?"ClosestFacility":"ServiceAreas",c=await s(a+("/"===a[a.length-1]?"":"/")+"GetTravelModes/execute",{query:{f:"json",serviceName:l}}),u=[];let f=null;if(c&&c.data&&c.data.results&&c.data.results.length){const e=c.data.results;for(const t of e)if("supportedTravelModes"===t.paramName){if(t.value&&t.value.features)for(const{attributes:e}of t.value.features)if(e){const t=JSON.parse(e.TravelMode);u.push(t)}}else"defaultTravelMode"===t.paramName&&(f=t.value)}return{supportedTravelModes:u,defaultTravelMode:f}}(e),{defaultTravelMode:n,supportedTravelModes:l}=await a;return t.defaultTravelMode=n,t.supportedTravelModes=l,t}_isInputGeometryZAware(e,t){for(let r=0;r<t.length;r++){const s=e[t[r]];if(s&&s.length)for(const e of s)if(a(e)&&e.hasZ)return!0}return!1}_dropZValuesOffInputGeometry(e,t){for(let r=0;r<t.length;r++){const s=e[t[r]];if(s&&s.length)for(const e of s)e.z=void 0}console.log("The remote Network Analysis service is powered by a network dataset which is not Z-aware.\nZ-coordinates of the input geometry are ignored.")}};return l=e([t("esri.tasks.mixins.NAServiceDescription")],l),l};let v=class extends(p(c)){};v=e([t("esri.tasks.mixins.NAServiceDescription")],v);const y=new n({0:"informative",1:"process-definition",2:"process-start",3:"process-stop",50:"warning",100:"error",101:"empty",200:"abort"});let w=class extends u{constructor(e){super(e),this.type=null}};e([l({type:String,json:{read:y.read,write:y.write}})],w.prototype,"type",void 0),w=e([t("esri.tasks.support.NAMessage")],w);var h=w;export{h as c,d as e,p as n}