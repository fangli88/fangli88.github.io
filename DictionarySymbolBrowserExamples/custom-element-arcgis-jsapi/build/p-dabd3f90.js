import"./p-476cf7c4.js";import{aa as t,du as e,U as s,i,X as n,b as r,ad as o}from"./p-ab028778.js";import"./p-098cc742.js";import{r as c}from"./p-50ee3927.js";import"./p-f6aca36e.js";import{t as h,n as a,f as l,h as f,a as u,r as d,D as w,u as p,P as y,b as M,c as x}from"./p-a6005503.js";import{l as m,t as b,s as g,n as k,u as I,r as _,i as T,a as v,b as A,e as L}from"./p-6258c9fc.js";var N;function S(t){return 746===t||747===t||!(t<4352)&&(t>=12704&&t<=12735||t>=12544&&t<=12591||t>=65072&&t<=65103&&!(t>=65097&&t<=65103)||t>=63744&&t<=64255||t>=13056&&t<=13311||t>=11904&&t<=12031||t>=12736&&t<=12783||t>=12288&&t<=12351&&!(t>=12296&&t<=12305||t>=12308&&t<=12319||12336===t)||t>=13312&&t<=19903||t>=19968&&t<=40959||t>=12800&&t<=13055||t>=12592&&t<=12687||t>=43360&&t<=43391||t>=55216&&t<=55295||t>=4352&&t<=4607||t>=44032&&t<=55215||t>=12352&&t<=12447||t>=12272&&t<=12287||t>=12688&&t<=12703||t>=12032&&t<=12255||t>=12784&&t<=12799||t>=12448&&t<=12543&&12540!==t||t>=65280&&t<=65519&&!(65288===t||65289===t||65293===t||t>=65306&&t<=65310||65339===t||65341===t||65343===t||t>=65371&&t<=65503||65507===t||t>=65512&&t<=65519)||t>=65104&&t<=65135&&!(t>=65112&&t<=65118||t>=65123&&t<=65126)||t>=5120&&t<=5759||t>=6320&&t<=6399||t>=65040&&t<=65055||t>=19904&&t<=19967||t>=40960&&t<=42127||t>=42128&&t<=42191)}!function(t){t[t.INITIALIZED=0]="INITIALIZED",t[t.NO_DATA=1]="NO_DATA",t[t.READY=2]="READY",t[t.MODIFIED=3]="MODIFIED",t[t.INVALID=4]="INVALID"}(N||(N={}));const D=24;class P{constructor(t,e,s,i,n,r,o){this._glyphItems=t,this._maxWidth=e,this._lineHeight=s,this._letterSpacing=i,this._hAnchor=n,this._vAnchor=r,this._justify=o}getShaping(t,e,s){const i=this._letterSpacing,n=this._lineHeight,r=this._justify,o=this._maxWidth,c=[];let h=0,a=0,l=0,f=0,u=-1,d=0,w=-1;const p=t.length;for(let y=0;y<p;y++){const M=t.charCodeAt(y),x=s&&S(M);if(10===M){if(y===p-1)continue;if(u>=f){const t=c[u];d=Math.max(t.x+t.glyphMosaicItem.metrics.advance,d),r&&this._applyJustification(c,f,u),f=c.length}e?a-=n:a+=n,h=0,++l;continue}let m;for(const t of this._glyphItems)if(m=t[M],m)break;if(m){if(c.push({codePoint:M,x:h,y:a,vertical:x,glyphMosaicItem:m}),h+=m.metrics.advance+i,o>0&&h>o&&w>=0){const t=w+1,s=c[t].x;d=Math.max(s,d);for(let i=t;i<c.length;i++)e?c[i].y-=n:c[i].y+=n,c[i].x-=s;r&&this._applyJustification(c,f,w),e?a-=n:a+=n,h-=s,++l,f=t,w=-1}++u,32===M&&(w=c.length-1)}}if(u>=f){const t=c[u];d=Math.max(d,t.x+t.glyphMosaicItem.metrics.advance),r&&this._applyJustification(c,f,u)}if(c.length>0){const t=(r-this._hAnchor)*d;let s=(-this._vAnchor*(l+1)+.5)*n;e&&l&&(s+=l*n);for(const e of c)e.x+=t,e.y+=s}return c}static getTextBox(t,e){if(!t.length)return null;let s=1/0,i=1/0,n=0,r=0;for(const o of t){const t=o.x,c=o.y-17,h=t+o.glyphMosaicItem.metrics.advance,a=c+e;s=Math.min(s,t),n=Math.max(n,h),i=Math.min(i,c),r=Math.max(r,a)}return{x:s,y:i,width:n-s,height:r-i}}static getBox(t){if(!t.length)return null;let e=1/0,s=1/0,i=0,n=0;for(const r of t){const{height:t,left:o,top:c,width:h}=r.glyphMosaicItem.metrics,a=r.x,l=r.y-(t-Math.abs(c)),f=a+h+o,u=l+t;e=Math.min(e,a),i=Math.max(i,f),s=Math.min(s,l),n=Math.max(n,u)}return{x:e,y:s,width:i-e,height:n-s}}static addDecoration(t,e){const s=t.length;if(0===s)return;let i=t[0].x+t[0].glyphMosaicItem.metrics.left,n=t[0].y;for(let r=1;r<s;r++){const s=t[r];if(s.y!==n){const o=t[r-1].x+t[r-1].glyphMosaicItem.metrics.left+t[r-1].glyphMosaicItem.metrics.width;t.push({codePoint:0,x:i,y:n+e-3,vertical:!1,glyphMosaicItem:{sdf:!0,rect:new m(4,0,4,8),metrics:{width:o-i,height:8,left:0,top:0,advance:0},page:0,code:0}}),n=s.y,i=s.x+s.glyphMosaicItem.metrics.left}}const r=t[s-1].x+t[s-1].glyphMosaicItem.metrics.left+t[s-1].glyphMosaicItem.metrics.width;t.push({codePoint:0,x:i,y:n+e-3,vertical:!1,glyphMosaicItem:{sdf:!0,rect:new m(4,0,4,8),metrics:{width:r-i,height:8,left:0,top:0,advance:0},page:0,code:0}})}_applyJustification(t,e,s){const i=t[s],n=(i.x+(i.vertical?24:i.glyphMosaicItem.metrics.advance))*this._justify;for(let i=e;i<=s;i++)t[i].x-=n}}class B{constructor(t,e,s=0,i=-1,n=.5){this.x=t,this.y=e,this.angle=s,this.segment=i,this.minzoom=n}}class F{constructor(t,e,s,i,n,r=.5,o=a){this.anchor=t,this.labelAngle=e,this.glyphAngle=s,this.page=i,this.alternateVerticalGlyph=n,this.minzoom=r,this.maxzoom=o}}class z{constructor(t,e,s,i,n,r,o,c,h,a,l,f){this.tl=t,this.tr=e,this.bl=s,this.br=i,this.mosaicRect=n,this.labelAngle=r,this.minAngle=o,this.maxAngle=c,this.anchor=h,this.minzoom=a,this.maxzoom=l,this.page=f}}class E{constructor(t){this.shapes=t}}class U{getIconPlacement(t,e,s){const i=new b(t.x,t.y),n=0===s.rotationAlignment,r=s.keepUpright;let o=s.rotate*l;n&&(o+=t.angle);const c=new E([]);return s.allowOverlap&&s.ignorePlacement||(c.iconColliders=[]),this._addIconPlacement(c,i,e,s,o),n&&r&&this._addIconPlacement(c,i,e,s,o+h),c}_addIconPlacement(t,e,s,i,n){const r=s.pixelRatio,o=s.width/r,c=s.height/r,h=i.offset;let l=h[0],f=h[1];switch(i.anchor){case 0:l-=o/2,f-=c/2;break;case 1:f-=c/2;break;case 2:l-=o,f-=c/2;break;case 3:l-=o/2;break;case 4:l-=o/2,f-=c;break;case 5:break;case 7:f-=c;break;case 6:l-=o;break;case 8:l-=o,f-=c}const u=s.rect,d=2/r,w=l-d,p=f-d,y=w+u.width/r,M=p+u.height/r,x=new b(w,p),m=new b(y,M),g=new b(w,M),k=new b(y,p);if(0!==n){const t=Math.cos(n),e=Math.sin(n);x.rotate(t,e),m.rotate(t,e),g.rotate(t,e),k.rotate(t,e)}const I=new z(x,k,g,m,u,n,0,256,e,.5,a,0);if(t.shapes.push(I),!i.allowOverlap||!i.ignorePlacement){const s=i.size,r=i.padding;t.iconColliders.push({xTile:e.x,yTile:e.y,dxPixels:l*s-r,dyPixels:f*s-r,hard:!i.optional,partIndex:0,width:o*s+2*r,height:c*s+2*r,angle:n,minLod:.5,maxLod:a})}}getTextPlacement(t,e,s,i){const n=new b(t.x,t.y),r=i.rotate*l,o=0===i.rotationAlignment,c=i.keepUpright,f=i.padding;let u=.5;const d=o?t.angle:0,w=t.segment>=0&&o,p=i.allowOverlap&&i.ignorePlacement?null:[],y=[],M=!w;let x=Number.POSITIVE_INFINITY,m=Number.NEGATIVE_INFINITY,g=x,k=m;const I=(w||o)&&c,_=i.size/D;let T=!1;for(const t of e)if(t.vertical){T=!0;break}let v,A=0,L=0;if(!w&&T){const t=P.getTextBox(e,i.lineHeight*D);switch(i.anchor){case 1:A=t.height/2,L=-t.width/2;break;case 2:A=-t.height/2,L=t.width/2;break;case 3:A=t.height/2,L=t.width/2;break;case 4:A=-t.height/2,L=-t.width/2;break;case 5:A=t.height;break;case 7:L=-t.width;break;case 6:L=t.width;break;case 8:A=-t.height}}A+=i.offset[0]*D,L+=i.offset[1]*D;for(const l of e){const e=l.glyphMosaicItem;if(!e||e.rect.isEmpty)continue;const N=e.rect,S=e.metrics,D=e.page;if(p&&M){if(void 0!==v&&v!==l.y){let e,s,n,o;T?(e=-k+A,s=x+L,n=k-g,o=m-x):(e=x+A,s=g+L,n=m-x,o=k-g),p.push({xTile:t.x,yTile:t.y,dxPixels:e*_-f,dyPixels:s*_-f,hard:!i.optional,partIndex:1,width:n*_+2*f,height:o*_+2*f,angle:r,minLod:.5,maxLod:a}),x=Number.POSITIVE_INFINITY,m=Number.NEGATIVE_INFINITY,g=x,k=m}v=l.y}const P=[];if(w){const i=(l.x+S.left-4+.5*e.metrics.width)*_*8;if(u=this._placeGlyph(t,u,i,s,t.segment,1,l.vertical,D,P),c&&(u=this._placeGlyph(t,u,i,s,t.segment,-1,l.vertical,D,P)),u>=2)break}else P.push(new F(n,d,d,D,!1)),o&&c&&P.push(new F(n,d+h,d+h,D,!1));const B=l.x+S.left,E=l.y-17-S.top,U=B+S.width,j=E+S.height;let C,O,R,V,G,q,J,W;!w&&T?l.vertical?(C=new b(-((E+j)/2+S.width/2)-4+A,(B+U)/2-S.height/2-4+L),O=new b(C.x+N.width,C.y+N.height),R=new b(C.x,O.y),V=new b(O.x,C.y)):(C=new b(4-E+A,B-4+L),O=new b(C.x-N.height,C.y+N.width),R=new b(O.x,C.y),V=new b(C.x,O.y)):(C=new b(B-4+A,E-4+L),O=new b(C.x+N.width,C.y+N.height),R=new b(C.x,O.y),V=new b(O.x,C.y));for(const e of P){let s,n,o,c;e.alternateVerticalGlyph?(G||(G=new b((B+U)/2+A-S.height/2-4,(E+j)/2+L+S.width/2+4),q=new b(G.x+N.height,G.y-N.width),J=new b(q.x,G.y),W=new b(G.x,q.y)),s=G,n=J,o=W,c=q):(s=C,n=R,o=V,c=O);const h=E,a=j,u=e.glyphAngle+r;if(0!==u){const t=Math.cos(u),e=Math.sin(u);s=s.clone(),n=n.clone(),o=o.clone(),c=c.clone(),s.rotate(t,e),c.rotate(t,e),n.rotate(t,e),o.rotate(t,e)}let d=0,v=256;w&&T?l.vertical?e.alternateVerticalGlyph?(d=32,v=96):(d=224,v=32):(d=224,v=96):(d=192,v=64),y.push(new z(s,o,n,c,N,e.labelAngle,d,v,e.anchor,e.minzoom,e.maxzoom,e.page)),!p||I&&!this._legible(e.labelAngle)||(M?(B<x&&(x=B),h<g&&(g=h),U>m&&(m=U),a>k&&(k=a)):e.minzoom<2&&p.push({xTile:t.x,yTile:t.y,dxPixels:(B+A)*_-f,dyPixels:(h+A)*_-f,hard:!i.optional,partIndex:1,width:(U-B)*_+2*f,height:(a-h)*_+2*f,angle:u,minLod:e.minzoom,maxLod:e.maxzoom}))}}if(u>=2)return null;if(p&&M){let e,s,n,o;T?(e=-k+A,s=x+L,n=k-g,o=m-x):(e=x+A,s=g+L,n=m-x,o=k-g),p.push({xTile:t.x,yTile:t.y,dxPixels:e*_-f,dyPixels:s*_-f,hard:!i.optional,partIndex:1,width:n*_+2*f,height:o*_+2*f,angle:r,minLod:.5,maxLod:a})}const N=new E(y);return p&&p.length>0&&(N.textColliders=p),N}_legible(t){const e=f(t);return e<65||e>=193}_placeGlyph(t,e,s,i,n,r,o,c,l){let f=r;const w=f<0?u(t.angle+h,d):t.angle;let p=0;s<0&&(f*=-1,s*=-1,p=h),f>0&&++n;let y=new b(t.x,t.y),M=i[n],x=a;if(i.length<=n)return x;for(;;){const t=M.x-y.x,r=M.y-y.y,h=Math.sqrt(t*t+r*r),a=Math.max(s/h,e),m=u(Math.atan2(r/h,t/h)+p,d);if(l.push(new F(y,w,m,c,!1,a,x)),o&&l.push(new F(y,w,m,c,!0,a,x)),a<=e)return a;y=M.clone();do{if(i.length<=(n+=f)||n<0)return a;M=i[n]}while(y.isEqual(M));let b=M.x-y.x,g=M.y-y.y;const k=Math.sqrt(b*b+g*g);b*=h/k,g*=h/k,y.x-=b,y.y-=g,x=a}}}class j{constructor(t,e){this.layerExtent=4096,this._features=[],this.layer=t,this.zoom=e,this._filter=t.getFeatureFilter()}pushFeature(t){this._filter&&!this._filter.filter(t,this.zoom)||this._features.push(t)}hasFeatures(){return this._features.length>0}}class C extends j{constructor(t,e,s,i){super(t,e),this.type=4,this._circleVertexBuffer=s,this._circleIndexBuffer=i}get circleIndexStart(){return this._circleIndexStart}get circleIndexCount(){return this._circleIndexCount}processFeatures(t){const e=this._circleVertexBuffer,s=this._circleIndexBuffer;this._circleIndexStart=3*s.index,this._circleIndexCount=0;const i=this.layer,n=this.zoom;t&&t.setExtent(this.layerExtent);let r=1,o=[1,1,1,1],c=1,h=0,a=1,l=[1,1,1,1],f=1;for(const u of this._features){const d=u.getGeometry(t);if(d){i.hasDataDrivenRadius&&(r=i.getPaintValue("circle-radius",n,u)),i.hasDataDrivenColor&&(o=i.getPaintValue("circle-color",n,u)),i.hasDataDrivenOpacity&&(c=i.getPaintValue("circle-opacity",n,u)),i.hasDataDrivenStrokeWidth&&(a=i.getPaintValue("circle-stroke-width",n,u)),i.hasDataDrivenStrokeColor&&(l=i.getPaintValue("circle-stroke-color",n,u)),i.hasDataDrivenStrokeOpacity&&(f=i.getPaintValue("circle-stroke-opacity",n,u)),i.hasDataDrivenBlur&&(h=i.getPaintValue("circle-blur",n,u));for(const t of d)if(t)for(const i of t){const t=e.index;e.add(i.x,i.y,0,0,r,o,c,h,a,l,f),e.add(i.x,i.y,0,1,r,o,c,h,a,l,f),e.add(i.x,i.y,1,0,r,o,c,h,a,l,f),e.add(i.x,i.y,1,1,r,o,c,h,a,l,f),s.add(t+0,t+1,t+2),s.add(t+1,t+2,t+3),this._circleIndexCount+=6}}}}serialize(){let t=6;t+=this.layerUIDs.length,t+=this._circleVertexBuffer.array.length,t+=this._circleIndexBuffer.array.length;let e=0;const s=new Uint32Array(t),i=new Int32Array(s.buffer);s[e++]=this.type,s[e++]=this.layerUIDs.length;for(let t=0;t<this.layerUIDs.length;t++)s[e++]=this.layerUIDs[t];s[e++]=this._circleIndexStart,s[e++]=this._circleIndexCount,s[e++]=this._circleVertexBuffer.array.length;for(let t=0;t<this._circleVertexBuffer.array.length;t++)i[e++]=this._circleVertexBuffer.array[t];s[e++]=this._circleIndexBuffer.array.length;for(let t=0;t<this._circleIndexBuffer.array.length;t++)s[e++]=this._circleIndexBuffer.array[t];return s.buffer}}class O{constructor(t,e){this.values={};const s=e.keys,i=e.values;for(;t.next();)switch(t.tag()){case 1:this.id=t.getUInt64();break;case 2:{const e=t.getMessage(),n=this.values;for(;!e.empty();){const t=e.getUInt32(),r=e.getUInt32();n[s[t]]=i[r]}e.release();break}case 3:this.type=t.getUInt32();break;case 4:this._pbfGeometry=t.getMessage();break;default:t.skip()}}getGeometry(t){if(void 0!==this._geometry)return this._geometry;if(!this._pbfGeometry)return null;const e=this._pbfGeometry;let s,i;this._pbfGeometry=null,t?t.reset(this.type):s=[];let n,r=1,o=0,c=0,h=0;for(;!e.empty();){if(0===o){const t=e.getUInt32();r=7&t,o=t>>3}switch(o--,r){case 1:c+=e.getSInt32(),h+=e.getSInt32(),t?t.moveTo(c,h):(i&&s.push(i),i=[],i.push(new b(c,h)));break;case 2:c+=e.getSInt32(),h+=e.getSInt32(),t?t.lineTo(c,h):i.push(new b(c,h));break;case 7:t?t.close():i&&!i[0].equals(c,h)&&i.push(i[0].clone());break;default:throw e.release(),new Error("Invalid path operation")}}return t?n=t.result():(i&&s.push(i),n=s),e.release(),this._geometry=n,n}}function R(t,e,s,i,n){let r;if(n===$(t,e,s,i)>0)for(let n=e;n<s;n+=i)r=W(n,t[n],t[n+1],r);else for(let n=s-i;n>=e;n-=i)r=W(n,t[n],t[n+1],r);return r&&it(r,r.next)&&(Y(r),r=r.next),r}function V(t,e=t){if(!t)return t;let s,i=t;do{if(s=!1,i.steiner||!it(i,i.next)&&0!==Z(i.prev,i,i.next))i=i.next;else{if(Y(i),i=e=i.prev,i===i.next)break;s=!0}}while(s||i!==e);return e}function G(t,e,s,i,n,r,o=0){if(!t)return;!o&&r&&(t=X(t,i,n,r));let c=t;for(;t.prev!==t.next;){const h=t.prev,a=t.next;if(r?J(t,i,n,r):q(t))e.push(h.index/s),e.push(t.index/s),e.push(a.index/s),Y(t),t=a.next,c=a.next;else if((t=a)===c){o?1===o?G(t=rt(t,e,s),e,s,i,n,r,2):2===o&&ot(t,e,s,i,n,r):G(V(t),e,s,i,n,r,1);break}}}function q(t){const e=t.prev,s=t,i=t.next;if(Z(e,s,i)>=0)return!1;let n=t.next.next;const r=n;let o=0;for(;n!==t.prev&&(0===o||n!==r);){if(o++,tt(e.x,e.y,s.x,s.y,i.x,i.y,n.x,n.y)&&Z(n.prev,n,n.next)>=0)return!1;n=n.next}return!0}function J(t,e,s,i){const n=t.prev,r=t,o=t.next;if(Z(n,r,o)>=0)return!1;const c=n.x>r.x?n.x>o.x?n.x:o.x:r.x>o.x?r.x:o.x,h=n.y>r.y?n.y>o.y?n.y:o.y:r.y>o.y?r.y:o.y,a=st(n.x<r.x?n.x<o.x?n.x:o.x:r.x<o.x?r.x:o.x,n.y<r.y?n.y<o.y?n.y:o.y:r.y<o.y?r.y:o.y,e,s,i),l=st(c,h,e,s,i);let f=t.prevZ,u=t.nextZ;for(;f&&f.z>=a&&u&&u.z<=l;){if(f!==t.prev&&f!==t.next&&tt(n.x,n.y,r.x,r.y,o.x,o.y,f.x,f.y)&&Z(f.prev,f,f.next)>=0)return!1;if(f=f.prevZ,u!==t.prev&&u!==t.next&&tt(n.x,n.y,r.x,r.y,o.x,o.y,u.x,u.y)&&Z(u.prev,u,u.next)>=0)return!1;u=u.nextZ}for(;f&&f.z>=a;){if(f!==t.prev&&f!==t.next&&tt(n.x,n.y,r.x,r.y,o.x,o.y,f.x,f.y)&&Z(f.prev,f,f.next)>=0)return!1;f=f.prevZ}for(;u&&u.z<=l;){if(u!==t.prev&&u!==t.next&&tt(n.x,n.y,r.x,r.y,o.x,o.y,u.x,u.y)&&Z(u.prev,u,u.next)>=0)return!1;u=u.nextZ}return!0}function W(t,e,s,i){const n=new at(t,e,s);return i?(n.next=i.next,n.prev=i,i.next.prev=n,i.next=n):(n.prev=n,n.next=n),n}function Y(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)}function H(t){let e=t,s=t;do{(e.x<s.x||e.x===s.x&&e.y<s.y)&&(s=e),e=e.next}while(e!==t);return s}function K(t,e){if(e=function(t,e){let s=e;const i=t.x,n=t.y;let r,o=-1/0;do{if(n<=s.y&&n>=s.next.y&&s.next.y!==s.y){const t=s.x+(n-s.y)*(s.next.x-s.x)/(s.next.y-s.y);if(t<=i&&t>o){if(o=t,t===i){if(n===s.y)return s;if(n===s.next.y)return s.next}r=s.x<s.next.x?s:s.next}}s=s.next}while(s!==e);if(!r)return null;if(i===o)return r.prev;const c=r,h=r.x,a=r.y;let l,f=1/0;for(s=r.next;s!==c;)i>=s.x&&s.x>=h&&i!==s.x&&tt(n<a?i:o,n,h,a,n<a?o:i,n,s.x,s.y)&&(l=Math.abs(n-s.y)/(i-s.x),(l<f||l===f&&s.x>r.x)&&et(s,t)&&(r=s,f=l)),s=s.next;return r}(t,e)){const s=ht(e,t);V(s,s.next)}}function X(t,e,s,i){for(let n;n!==t;n=n.next){if(n=n||t,null===n.z&&(n.z=st(n.x,n.y,e,s,i)),n.prev.next!==n||n.next.prev!==n)return n.prev.next=n,n.next.prev=n,X(t,e,s,i);n.prevZ=n.prev,n.nextZ=n.next}return t.prevZ.nextZ=null,t.prevZ=null,function(t){let e,s=1;for(;;){let i,n=t;t=null,e=null;let r=0;for(;n;){r++,i=n;let o=0;for(;o<s&&i;o++)i=i.nextZ;let c=s;for(;o>0||c>0&&i;){let s;0===o?(s=i,i=i.nextZ,c--):0!==c&&i?n.z<=i.z?(s=n,n=n.nextZ,o--):(s=i,i=i.nextZ,c--):(s=n,n=n.nextZ,o--),e?e.nextZ=s:t=s,s.prevZ=e,e=s}n=i}if(e.nextZ=null,s*=2,r<2)return t}}(t)}function Z(t,e,s){return(e.y-t.y)*(s.x-e.x)-(e.x-t.x)*(s.y-e.y)}function Q(t,e,s,i){return!!(it(t,e)&&it(s,i)||it(t,i)&&it(s,e))||Z(t,e,s)>0!=Z(t,e,i)>0&&Z(s,i,t)>0!=Z(s,i,e)>0}function $(t,e,s,i){let n=0;for(let r=e,o=s-i;r<s;r+=i)n+=(t[o]-t[r])*(t[r+1]+t[o+1]),o=r;return n}function tt(t,e,s,i,n,r,o,c){return(n-o)*(e-c)-(t-o)*(r-c)>=0&&(t-o)*(i-c)-(s-o)*(e-c)>=0&&(s-o)*(r-c)-(n-o)*(i-c)>=0}function et(t,e){return Z(t.prev,t,t.next)<0?Z(t,e,t.next)>=0&&Z(t,t.prev,e)>=0:Z(t,e,t.prev)<0||Z(t,t.next,e)<0}function st(t,e,s,i,n){return(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=32767*(t-s)*n)|t<<8))|t<<4))|t<<2))|t<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=32767*(e-i)*n)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function it(t,e){return t.x===e.x&&t.y===e.y}function nt(t,e){return t.x-e.x}function rt(t,e,s){let i=t;do{const n=i.prev,r=i.next.next;!it(n,r)&&Q(n,i,i.next,r)&&et(n,r)&&et(r,n)&&(e.push(n.index/s),e.push(i.index/s),e.push(r.index/s),Y(i),Y(i.next),i=t=r),i=i.next}while(i!==t);return i}function ot(t,e,s,i,n,r){let o=t;do{let t=o.next.next;for(;t!==o.prev;){if(o.index!==t.index&&ct(o,t)){let c=ht(o,t);return o=V(o,o.next),c=V(c,c.next),G(o,e,s,i,n,r),void G(c,e,s,i,n,r)}t=t.next}o=o.next}while(o!==t)}function ct(t,e){return t.next.index!==e.index&&t.prev.index!==e.index&&!function(t,e){let s=t;do{if(s.index!==t.index&&s.next.index!==t.index&&s.index!==e.index&&s.next.index!==e.index&&Q(s,s.next,t,e))return!0;s=s.next}while(s!==t);return!1}(t,e)&&et(t,e)&&et(e,t)&&function(t,e){let s=t,i=!1;const n=(t.x+e.x)/2,r=(t.y+e.y)/2;do{s.y>r!=s.next.y>r&&s.next.y!==s.y&&n<(s.next.x-s.x)*(r-s.y)/(s.next.y-s.y)+s.x&&(i=!i),s=s.next}while(s!==t);return i}(t,e)}function ht(t,e){const s=new at(t.index,t.x,t.y),i=new at(e.index,e.x,e.y),n=t.next,r=e.prev;return t.next=e,e.prev=t,s.next=n,n.prev=s,i.next=s,s.prev=i,r.next=i,i.prev=r,i}class at{constructor(t,e,s){this.index=t,this.x=e,this.y=s,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}}const lt=new g;class ft extends j{constructor(t,e,s,i,n,r){if(super(t,e),this.type=1,t.hasDataDrivenFill!==s.isDataDriven())throw new Error("incompatible fill buffer");if(t.hasDataDrivenOutline!==n.isDataDriven())throw new Error("incompatible outline buffer");this._fillVertexBuffer=s,this._fillIndexBuffer=i,this._outlineVertexBuffer=n,this._outlineIndexBuffer=r}get fillIndexStart(){return this._fillIndexStart}get fillIndexCount(){return this._fillIndexCount}get outlineIndexStart(){return this._outlineIndexStart}get outlineIndexCount(){return this._outlineIndexCount}processFeatures(t){this._fillIndexStart=3*this._fillIndexBuffer.index,this._fillIndexCount=0,this._outlineIndexStart=3*this._outlineIndexBuffer.index,this._outlineIndexCount=0;const e=this.layer,s=this.zoom,i=e.hasDataDrivenFill,n=e.hasDataDrivenOutline;t&&t.setExtent(this.layerExtent);const r=e.getPaintValue("fill-pattern",s);let o=e.getPaintValue("fill-antialias",s)&&void 0===r,c=[1,1,1,1],h=[1,1,1,1],a=1;if(e.outlineUsesFillColor){if(o&&!e.hasDataDrivenOpacity){const t=e.getPaintValue("fill-opacity",s),i=e.getPaintValue("fill-opacity",s+1);t<1&&i<1&&(o=!1)}if(o&&!e.hasDataDrivenColor){const t=e.getPaintValue("fill-color",s),i=e.getPaintValue("fill-color",s+1);t[3]<1&&i[3]<1&&(o=!1)}}for(const l of this._features){let f,u;!r&&e.hasDataDrivenColor&&(c=e.getPaintValue("fill-color",s,l)),e.hasDataDrivenOpacity&&(a=e.getPaintValue("fill-opacity",s,l)),!r&&e.hasDataDrivenOutlineColor&&(h=e.getPaintValue("fill-outline-color",s,l)),i&&(f={color:c,opacity:a}),n&&(u={color:e.outlineUsesFillColor?c:h,opacity:a});const d=l.getGeometry(t);this._processFeature(d,o,e.outlineUsesFillColor,f,u,null==t?void 0:t.validateTessellation)}}serialize(){let t=12;t+=this.layerUIDs.length,t+=this._fillVertexBuffer.array.length,t+=this._fillIndexBuffer.array.length,t+=this._outlineVertexBuffer.array.length,t+=this._outlineIndexBuffer.array.length;let e=0;const s=new Uint32Array(t),i=new Int32Array(s.buffer);s[e++]=this.type,s[e++]=this.layerUIDs.length;for(let t=0;t<this.layerUIDs.length;t++)s[e++]=this.layerUIDs[t];s[e++]=this._fillIndexStart,s[e++]=this._fillIndexCount,s[e++]=this._outlineIndexStart,s[e++]=this._outlineIndexCount,s[e++]=this._fillVertexBuffer.isDataDriven()?1:0,s[e++]=this._outlineVertexBuffer.isDataDriven()?1:0,s[e++]=this._fillVertexBuffer.array.length;for(let t=0;t<this._fillVertexBuffer.array.length;t++)i[e++]=this._fillVertexBuffer.array[t];s[e++]=this._fillIndexBuffer.array.length;for(let t=0;t<this._fillIndexBuffer.array.length;t++)s[e++]=this._fillIndexBuffer.array[t];s[e++]=this._outlineVertexBuffer.array.length;for(let t=0;t<this._outlineVertexBuffer.array.length;t++)i[e++]=this._outlineVertexBuffer.array[t];s[e++]=this._outlineIndexBuffer.array.length;for(let t=0;t<this._outlineIndexBuffer.array.length;t++)s[e++]=this._outlineIndexBuffer.array[t];return s.buffer}_processFeature(t,e,s,i,n,r){if(!t)return;const o=t.length;if(e&&(!s||!n||n.color[3]*n.opacity==1))for(let e=0;e<o;e++)this._processOutline(t[e],n);let c;for(let e=0;e<o;e++){const s=ft._area(t[e]);s>128?(void 0!==c&&this._processFill(t,c,i,r),c=[e]):s<-128&&void 0!==c&&c.push(e)}void 0!==c&&this._processFill(t,c,i,r)}_processOutline(t,e){const s=this._outlineVertexBuffer,i=this._outlineIndexBuffer,n=i.index;let r,o,c;const h=new b(0,0),a=new b(0,0),l=new b(0,0);let f=-1,u=-1,d=-1,w=-1,p=-1,y=!1,M=t.length;if(M<2)return;const x=t[0];let m=t[M-1];for(;M&&m.isEqual(x);)--M,m=t[M-1];if(!(M-0<2)){for(let n=0;n<M;++n){0===n?(r=t[M-1],o=t[0],c=t[1],h.assignSub(o,r),h.normalize(),h.rightPerpendicular()):(r=o,o=c,c=n!==M-1?t[n+1]:t[0],h.assign(a));const x=this._isClipEdge(r,o);-1===w&&(y=x),a.assignSub(c,o),a.normalize(),a.rightPerpendicular();const m=h.x*a.y-h.y*a.x;l.assignAdd(h,a),l.normalize();const b=-l.x*-h.x+-l.y*-h.y;let g=Math.abs(0!==b?1/b:1);g>8&&(g=8),m>=0?(d=s.add(o.x,o.y,h.x,h.y,0,1,e),-1===w&&(w=d),f>=0&&u>=0&&d>=0&&!x&&i.add(f,u,d),u=s.add(o.x,o.y,g*-l.x,g*-l.y,0,-1,e),-1===p&&(p=u),f>=0&&u>=0&&d>=0&&!x&&i.add(f,u,d),f=u,u=d,d=s.add(o.x,o.y,l.x,l.y,0,1,e),f>=0&&u>=0&&d>=0&&!x&&i.add(f,u,d),u=s.add(o.x,o.y,a.x,a.y,0,1,e),f>=0&&u>=0&&d>=0&&!x&&i.add(f,u,d)):(d=s.add(o.x,o.y,g*l.x,g*l.y,0,1,e),-1===w&&(w=d),f>=0&&u>=0&&d>=0&&!x&&i.add(f,u,d),u=s.add(o.x,o.y,-h.x,-h.y,0,-1,e),-1===p&&(p=u),f>=0&&u>=0&&d>=0&&!x&&i.add(f,u,d),f=u,u=d,d=s.add(o.x,o.y,-l.x,-l.y,0,-1,e),f>=0&&u>=0&&d>=0&&!x&&i.add(f,u,d),f=s.add(o.x,o.y,-a.x,-a.y,0,-1,e),f>=0&&u>=0&&d>=0&&!x&&i.add(f,u,d))}f>=0&&u>=0&&w>=0&&!y&&i.add(f,u,w),f>=0&&w>=0&&p>=0&&!y&&i.add(f,p,w),this._outlineIndexCount+=3*(i.index-n)}}_processFill(e,s,i,n){let r;s.length>1&&(r=[]);let o=0;for(const t of s)0!==o&&r.push(o),o+=e[t].length;const c=2*o,h=t.acquire();for(const t of s){const s=e[t],i=s.length;for(let t=0;t<i;++t)h.push(s[t].x,s[t].y)}const a=function(t,e){const s=e&&e.length,i=s?2*e[0]:t.length;let n=R(t,0,i,2,!0);const r=new Array;if(!n||n.next===n.prev)return r;let o,c,h,a,l;if(s&&(n=function(t,e,s){const i=new Array;for(let s=0,n=e.length;s<n;s++){const r=R(t,2*e[s],s<n-1?2*e[s+1]:t.length,2,!1);r===r.next&&(r.steiner=!0),i.push(H(r))}i.sort(nt);for(const t of i)K(t,s),s=V(s,s.next);return s}(t,e,n)),t.length>160){o=h=t[0],c=a=t[1];for(let e=2;e<i;e+=2){const s=t[e],i=t[e+1];o=Math.min(o,s),c=Math.min(c,i),h=Math.max(h,s),a=Math.max(a,i)}l=Math.max(h-o,a-c),l=0!==l?1/l:0}return G(n,r,2,o,c,l),r}(h,r);if(n&&function(t,e,s,i){const n=e&&e.length;let r=Math.abs($(t,0,n?2*e[0]:t.length,2));if(n)for(let s=0,i=e.length;s<i;s++)r-=Math.abs($(t,2*e[s],s<i-1?2*e[s+1]:t.length,2));let o=0;for(let e=0;e<i.length;e+=3){const s=2*i[e],n=2*i[e+1],r=2*i[e+2];o+=Math.abs((t[s]-t[r])*(t[n+1]-t[s+1])-(t[s]-t[n])*(t[r+1]-t[s+1]))}return 0===r&&0===o?0:Math.abs((o-r)/r)}(h,r,0,a)>0){const t=[],n=[];if(function(t,e,s,i){let n,r;lt.beginPolygon(t,e);for(const t of i){const e=s[t];if(!(e.length<3)){lt.beginContour();for(let t=0;t<e.length;++t){n=e[t].x,r=e[t].y;const s=[n,r,0];lt.addVertex(s,s)}lt.endContour()}}lt.endPolygon()}(t,n,e,s),n.length>0){const e=this._fillVertexBuffer.index;let s=0;for(;s<t.length;)this._fillVertexBuffer.add(t[s++],t[s++],i);let r=0;for(;r<n.length;)this._fillIndexBuffer.add(e+n[r+0],e+n[r+1],e+n[r+2]),r+=3;this._fillIndexCount+=n.length}}else{const t=a.length;if(t>0){const e=this._fillVertexBuffer.index;let s=0;for(;s<c;)this._fillVertexBuffer.add(h[s++],h[s++],i);let n=0;for(;n<t;)this._fillIndexBuffer.add(e+a[n++],e+a[n++],e+a[n++]);this._fillIndexCount+=t}}t.release(h)}_isClipEdge(t,e){return t.x===e.x?t.x<=-64||t.x>=4160:t.y===e.y&&(t.y<=-64||t.y>=4160)}static _area(t){let e=0;const s=t.length-1;for(let i=0;i<s;i++)e+=(t[i].x-t[i+1].x)*(t[i].y+t[i+1].y);return e+=(t[s].x-t[0].x)*(t[s].y+t[0].y),.5*e}}class ut{constructor(t){this._array=[],t<=0&&console.error("strideInBytes must be positive!"),this._stride=t}get array(){return this._array}get index(){return 4*this._array.length/this._stride}get itemSize(){return this._stride}get sizeInBytes(){return 4*this._array.length}reset(){this.array.length=0}toBuffer(){return new Uint32Array(this._array).buffer}static i1616to32(t,e){return 65535&t|e<<16}static i8888to32(t,e,s,i){return 255&t|(255&e)<<8|(255&s)<<16|i<<24}static i8816to32(t,e,s){return 255&t|(255&e)<<8|s<<16}}class dt extends ut{constructor(){super(12)}add(t,e,s){const i=this.array;i.push(t),i.push(e),i.push(s)}}const wt=t=>e=>{e.entry0=t._lineVertexBuffer.index,t._lineVertexBuffer.add(e.currentVertex.x,e.currentVertex.y,e.prevNormal.x,e.prevNormal.y,0,-1,e.distance,t._ddValues),e.entry2=t._lineVertexBuffer.index,t._lineVertexBuffer.add(e.currentVertex.x,e.currentVertex.y,-e.prevNormal.x,-e.prevNormal.y,0,1,e.distance,t._ddValues),e.exit0=t._lineVertexBuffer.index,t._lineVertexBuffer.add(e.currentVertex.x,e.currentVertex.y,e.nextNormal.x,e.nextNormal.y,0,-1,e.distance,t._ddValues),e.exit2=t._lineVertexBuffer.index,t._lineVertexBuffer.add(e.currentVertex.x,e.currentVertex.y,-e.nextNormal.x,-e.nextNormal.y,0,1,e.distance,t._ddValues)},pt=t=>e=>{t._lineIndexBuffer.add(e.leftExit0,e.rightEntry0,e.leftExit2),t._lineIndexBuffer.add(e.rightEntry0,e.rightEntry2,e.leftExit2)},yt=t=>e=>{const s=2===t._joinType?t._miterLimitCosine:t._roundLimitCosine,i=e.isCap&&0!==t._capType;let n,r=!1;if(e.cosine>.97?(e.exit0=e.entry0=t._lineVertexBuffer.index,t._lineVertexBuffer.add(e.currentVertex.x,e.currentVertex.y,e.bisector.x/e.cosine,e.bisector.y/e.cosine,0,-1,e.distance,t._ddValues),e.exit2=e.entry2=t._lineVertexBuffer.index,t._lineVertexBuffer.add(e.currentVertex.x,e.currentVertex.y,-e.bisector.x/e.cosine,-e.bisector.y/e.cosine,0,1,e.distance,t._ddValues)):e.cosine<1-.97?(e.entry0=t._lineVertexBuffer.index,t._lineVertexBuffer.add(e.currentVertex.x,e.currentVertex.y,e.prevNormal.x,e.prevNormal.y,0,-1,e.distance,t._ddValues),e.entry2=t._lineVertexBuffer.index,t._lineVertexBuffer.add(e.currentVertex.x,e.currentVertex.y,-e.prevNormal.x,-e.prevNormal.y,0,1,e.distance,t._ddValues),e.exit0=t._lineVertexBuffer.index,t._lineVertexBuffer.add(e.currentVertex.x,e.currentVertex.y,e.nextNormal.x,e.nextNormal.y,0,-1,e.distance,t._ddValues),e.exit2=t._lineVertexBuffer.index,t._lineVertexBuffer.add(e.currentVertex.x,e.currentVertex.y,-e.nextNormal.x,-e.nextNormal.y,0,1,e.distance,t._ddValues)):e.canSplit?(k(),e.sign>0?(e.splitInner?(e.exit0=t._lineVertexBuffer.index,t._lineVertexBuffer.add(e.currentVertex.x,e.currentVertex.y,e.leftInner.x,e.leftInner.y,0,-1,e.distance,t._ddValues),e.entry0=t._lineVertexBuffer.index,t._lineVertexBuffer.add(e.currentVertex.x,e.currentVertex.y,e.rightInner.x,e.rightInner.y,0,-1,e.distance,t._ddValues)):(e.exit0=e.entry0=t._lineVertexBuffer.index,t._lineVertexBuffer.add(e.currentVertex.x,e.currentVertex.y,e.bisector.x/e.cosine,e.bisector.y/e.cosine,0,-1,e.distance,t._ddValues)),e.cosine<s?(r=!e.isCap,e.entry2=t._lineVertexBuffer.index,t._lineVertexBuffer.add(e.currentVertex.x,e.currentVertex.y,-e.prevNormal.x,-e.prevNormal.y,0,1,e.distance,t._ddValues),e.exit2=t._lineVertexBuffer.index,t._lineVertexBuffer.add(e.currentVertex.x,e.currentVertex.y,-e.nextNormal.x,-e.nextNormal.y,0,1,e.distance,t._ddValues)):e.splitOuter?(r=r||e.gapOuter,e.entry2=t._lineVertexBuffer.index,t._lineVertexBuffer.add(e.currentVertex.x,e.currentVertex.y,-e.leftOuter.x,-e.leftOuter.y,0,1,e.distance,t._ddValues),e.exit2=t._lineVertexBuffer.index,t._lineVertexBuffer.add(e.currentVertex.x,e.currentVertex.y,-e.rightOuter.x,-e.rightOuter.y,0,1,e.distance,t._ddValues)):(e.entry2=e.exit2=t._lineVertexBuffer.index,t._lineVertexBuffer.add(e.currentVertex.x,e.currentVertex.y,-e.bisector.x/e.cosine,-e.bisector.y/e.cosine,0,1,e.distance,t._ddValues))):(e.splitInner?(e.exit2=t._lineVertexBuffer.index,t._lineVertexBuffer.add(e.currentVertex.x,e.currentVertex.y,-e.leftInner.x,-e.leftInner.y,0,1,e.distance,t._ddValues),e.entry2=t._lineVertexBuffer.index,t._lineVertexBuffer.add(e.currentVertex.x,e.currentVertex.y,-e.rightInner.x,-e.rightInner.y,0,1,e.distance,t._ddValues)):(e.exit2=e.entry2=t._lineVertexBuffer.index,t._lineVertexBuffer.add(e.currentVertex.x,e.currentVertex.y,-e.bisector.x/e.cosine,-e.bisector.y/e.cosine,0,1,e.distance,t._ddValues)),e.cosine<s?(r=!e.isCap,e.entry0=t._lineVertexBuffer.index,t._lineVertexBuffer.add(e.currentVertex.x,e.currentVertex.y,e.prevNormal.x,e.prevNormal.y,0,-1,e.distance,t._ddValues),e.exit0=t._lineVertexBuffer.index,t._lineVertexBuffer.add(e.currentVertex.x,e.currentVertex.y,e.nextNormal.x,e.nextNormal.y,0,-1,e.distance,t._ddValues)):e.splitOuter?(r=r||e.gapOuter,e.entry0=t._lineVertexBuffer.index,t._lineVertexBuffer.add(e.currentVertex.x,e.currentVertex.y,e.leftOuter.x,e.leftOuter.y,0,-1,e.distance,t._ddValues),e.exit0=t._lineVertexBuffer.index,t._lineVertexBuffer.add(e.currentVertex.x,e.currentVertex.y,e.rightOuter.x,e.rightOuter.y,0,-1,e.distance,t._ddValues)):(e.exit0=e.entry0=t._lineVertexBuffer.index,t._lineVertexBuffer.add(e.currentVertex.x,e.currentVertex.y,e.bisector.x/e.cosine,e.bisector.y/e.cosine,0,-1,e.distance,t._ddValues)))):e.sign>0?(e.exit0=e.entry0=t._lineVertexBuffer.index,t._lineVertexBuffer.add(e.currentVertex.x,e.currentVertex.y,e.bisector.x/e.cosine,e.bisector.y/e.cosine,0,-1,e.distance,t._ddValues),e.cosine<s?(r=!e.isCap,e.entry2=t._lineVertexBuffer.index,t._lineVertexBuffer.add(e.currentVertex.x,e.currentVertex.y,-e.prevNormal.x,-e.prevNormal.y,0,1,e.distance,t._ddValues),e.exit2=t._lineVertexBuffer.index,t._lineVertexBuffer.add(e.currentVertex.x,e.currentVertex.y,-e.nextNormal.x,-e.nextNormal.y,0,1,e.distance,t._ddValues)):(e.entry2=e.exit2=t._lineVertexBuffer.index,t._lineVertexBuffer.add(e.currentVertex.x,e.currentVertex.y,-e.bisector.x/e.cosine,-e.bisector.y/e.cosine,0,1,e.distance,t._ddValues))):(e.exit2=e.entry2=t._lineVertexBuffer.index,t._lineVertexBuffer.add(e.currentVertex.x,e.currentVertex.y,-e.bisector.x/e.cosine,-e.bisector.y/e.cosine,0,1,e.distance,t._ddValues),e.cosine<s?(r=!e.isCap,e.entry0=t._lineVertexBuffer.index,t._lineVertexBuffer.add(e.currentVertex.x,e.currentVertex.y,e.prevNormal.x,e.prevNormal.y,0,-1,e.distance,t._ddValues),e.exit0=t._lineVertexBuffer.index,t._lineVertexBuffer.add(e.currentVertex.x,e.currentVertex.y,e.nextNormal.x,e.nextNormal.y,0,-1,e.distance,t._ddValues)):(e.exit0=e.entry0=t._lineVertexBuffer.index,t._lineVertexBuffer.add(e.currentVertex.x,e.currentVertex.y,e.bisector.x/e.cosine,e.bisector.y/e.cosine,0,-1,e.distance,t._ddValues))),e.canSplit&&(e.splitInner||e.splitOuter)||r||i?(n=e.entry1=e.exit1=t._lineVertexBuffer.index,t._lineVertexBuffer.add(e.currentVertex.x,e.currentVertex.y,0,0,0,0,e.distance,t._ddValues)):n=e.entry1=e.exit1=null,r&&1!==t._joinType)t._lineIndexBuffer.add(n,e.sign>0?e.exit2:e.entry0,e.sign>0?e.entry2:e.exit0);else if(i&&1===t._capType||r&&1===t._joinType){let s,i,r,o,c,h;if(e.isCap){const t=Math.PI;c=Math.ceil(t/.8),h=t/c,e.isFirstVertex?(s=e.prevNormal.x,i=e.prevNormal.y,r=e.entry0,o=e.entry2):e.isLastVertex&&(s=-e.nextNormal.x,i=-e.nextNormal.y,r=e.exit2,o=e.exit0)}else{const t=2*Math.acos(e.cosine);c=Math.ceil(t/.8),h=t/c,s=e.sign>0?-e.prevNormal.x:e.nextNormal.x,i=e.sign>0?-e.prevNormal.y:e.nextNormal.y,r=e.sign>0?e.entry2:e.exit0,o=e.sign>0?e.exit2:e.entry0}const a=Math.cos(h),l=Math.sin(h),f=l*s+a*i;let u,d;s=a*s-l*i,i=f;for(let h=0;h<c;++h){u=d,h<c-1&&(e.isCap?(d=t._lineVertexBuffer.index,t._lineVertexBuffer.add(e.currentVertex.x,e.currentVertex.y,s,i,e.isFirstVertex?-1:1,0,e.distance,t._ddValues)):(d=t._lineVertexBuffer.index,t._lineVertexBuffer.add(e.currentVertex.x,e.currentVertex.y,s,i,0,e.sign,e.distance,t._ddValues))),t._lineIndexBuffer.add(0===h?r:u,n,h===c-1?o:d);const f=l*s+a*i;s=a*s-l*i,i=f}}else if(i&&2===t._capType){const s=e.isFirstVertex?1:-1;let i,r;t._hasPattern?(i=t._lineVertexBuffer.index,t._lineVertexBuffer.add(e.currentVertex.x,e.currentVertex.y,e.prevNormal.x-s*e.inbound.x,e.prevNormal.y-s*e.inbound.y,-s,-1,e.distance,t._ddValues),r=t._lineVertexBuffer.index,t._lineVertexBuffer.add(e.currentVertex.x,e.currentVertex.y,-e.prevNormal.x-s*e.inbound.x,-e.prevNormal.y-s*e.inbound.y,-s,1,e.distance,t._ddValues)):(i=t._lineVertexBuffer.index,t._lineVertexBuffer.add(e.currentVertex.x,e.currentVertex.y,e.prevNormal.x-s*e.inbound.x,e.prevNormal.y-s*e.inbound.y,0,-1,e.distance,t._ddValues),r=t._lineVertexBuffer.index,t._lineVertexBuffer.add(e.currentVertex.x,e.currentVertex.y,-e.prevNormal.x-s*e.inbound.x,-e.prevNormal.y-s*e.inbound.y,0,1,e.distance,t._ddValues)),s>0?(t._lineIndexBuffer.add(n,e.entry2,r),t._lineIndexBuffer.add(n,r,i),t._lineIndexBuffer.add(n,i,e.entry0)):(t._lineIndexBuffer.add(n,r,e.exit2),t._lineIndexBuffer.add(n,i,r),t._lineIndexBuffer.add(n,e.exit0,i))}},Mt=t=>e=>{t._lineIndexBuffer.add(e.leftExit0,e.rightEntry0,null!=e.leftExit1?e.leftExit1:e.leftExit2),t._lineIndexBuffer.add(e.rightEntry0,null!=e.rightEntry1?e.rightEntry1:e.rightEntry2,null!=e.leftExit1?e.leftExit1:e.leftExit2),null!=e.leftExit1&&null!=e.rightEntry1?(t._lineIndexBuffer.add(e.leftExit1,e.rightEntry1,e.leftExit2),t._lineIndexBuffer.add(e.rightEntry1,e.rightEntry2,e.leftExit2)):null!=e.leftExit1?t._lineIndexBuffer.add(e.leftExit1,e.rightEntry2,e.leftExit2):null!=e.rightEntry1&&t._lineIndexBuffer.add(e.rightEntry1,e.rightEntry2,e.leftExit2)};class xt extends j{constructor(t,e,s,i){if(super(t,e),this.type=2,this._tessellationOptions={},this.tessellationProperties={_lineVertexBuffer:null,_lineIndexBuffer:null,_hasPattern:null,_ddValues:null,_capType:null,_joinType:null,_miterLimitCosine:null,_roundLimitCosine:null},t.hasDataDrivenLine!==s.isDataDriven())throw new Error("incompatible line buffer");this.tessellationProperties._lineVertexBuffer=s,this.tessellationProperties._lineIndexBuffer=i,this.tessellationProperties._hasPattern=t.getPaintValue("line-pattern",this.zoom)||t.getPaintValue("line-dasharray",this.zoom).length>0,this._isThinLine=t.isThinLine,this._tessellationCallbacks=this._isThinLine?{vertex:wt(this.tessellationProperties),bridge:pt(this.tessellationProperties)}:{vertex:yt(this.tessellationProperties),bridge:Mt(this.tessellationProperties)}}get lineIndexStart(){return this._lineIndexStart}get lineIndexCount(){return this._lineIndexCount}processFeatures(t){this._lineIndexStart=3*this.tessellationProperties._lineIndexBuffer.index,this._lineIndexCount=0;const e=this.layer,s=this.zoom,i=e.hasDataDrivenLine;t&&t.setExtent(this.layerExtent);let n=[1,1,1,1],r=1,o=1;for(const c of this._features){let h;if(!this.tessellationProperties._hasPattern&&e.hasDataDrivenColor&&(n=e.getPaintValue("line-color",s,c)),e.hasDataDrivenOpacity&&(r=e.getPaintValue("line-opacity",s,c)),e.hasDataDrivenWidth&&(o=e.getPaintValue("line-width",s,c)),i&&(h={color:n,opacity:r,size:Math.max(Math.min(o,256),0)},h.size<=0||h.opacity<=0||h.color[3]<=0))continue;this.tessellationProperties._capType=e.getLayoutValue("line-cap",s,c),this.tessellationProperties._joinType=e.getLayoutValue("line-join",s,c),this.tessellationProperties._miterLimitCosine=I(e.getLayoutValue("line-miter-limit",s,c)),this.tessellationProperties._roundLimitCosine=I(e.getLayoutValue("line-round-limit",s,c));const a=c.getGeometry(t);this._processFeature(a,h)}T()}serialize(){let t=7;t+=this.layerUIDs.length,t+=this.tessellationProperties._lineVertexBuffer.array.length,t+=this.tessellationProperties._lineIndexBuffer.array.length;let e=0;const s=new Uint32Array(t),i=new Int32Array(s.buffer);s[e++]=this.type,s[e++]=this.layerUIDs.length;for(let t=0;t<this.layerUIDs.length;t++)s[e++]=this.layerUIDs[t];s[e++]=this._lineIndexStart,s[e++]=this._lineIndexCount,s[e++]=this.tessellationProperties._lineVertexBuffer.isDataDriven()?1:0,s[e++]=this.tessellationProperties._lineVertexBuffer.array.length;for(let t=0;t<this.tessellationProperties._lineVertexBuffer.array.length;t++)i[e++]=this.tessellationProperties._lineVertexBuffer.array[t];s[e++]=this.tessellationProperties._lineIndexBuffer.array.length;for(let t=0;t<this.tessellationProperties._lineIndexBuffer.array.length;t++)s[e++]=this.tessellationProperties._lineIndexBuffer.array[t];return s.buffer}_processFeature(t,e){if(!t)return;const s=t.length;for(let i=0;i<s;i++)this._processGeometry(t[i],e)}_processGeometry(t,e){if(t.length<2)return;let s,i,n=t[0],r=1;for(;r<t.length;)s=t[r].x-n.x,i=t[r].y-n.y,s*s+i*i<1e-6?t.splice(r,1):(n=t[r],++r);if(t.length<2)return;const o=3*this.tessellationProperties._lineIndexBuffer.index;this._tessellationOptions.trackDistance=this.tessellationProperties._hasPattern,this._tessellationOptions.initialDistance=0,this._tessellationOptions.thin=this._isThinLine,this._tessellationOptions.wrapDistance=65535,this._tessellationOptions.outerBisectorAutoSplitThreshold=.2631578947368421,this._tessellationOptions.enableOuterBisectorSplit=this.tessellationProperties._hasPattern,this._tessellationOptions.innerBisectorAutoSplitThreshold=.2631578947368421,this._tessellationOptions.enableInnerBisectorSplit=this.tessellationProperties._hasPattern,this.tessellationProperties._ddValues=e,_(t,this._tessellationOptions,this._tessellationCallbacks),this._lineIndexCount+=3*this.tessellationProperties._lineIndexBuffer.index-o}}class mt{constructor(t){for(this.extent=4096,this.keys=[],this.values=[],this._pbfLayer=t.clone();t.next();)switch(t.tag()){case 1:this.name=t.getString();break;case 3:this.keys.push(t.getString());break;case 4:this.values.push(t.processMessage(mt._parseValue));break;case 5:this.extent=t.getUInt32();break;default:t.skip()}}getData(){return this._pbfLayer}static _parseValue(t){for(;t.next();)switch(t.tag()){case 1:return t.getString();case 2:return t.getFloat();case 3:return t.getDouble();case 4:return t.getInt64();case 5:return t.getUInt64();case 6:return t.getSInt64();case 7:return t.getBool();default:t.skip()}return null}}function bt(t,e){return t.iconMosaicItem&&e.iconMosaicItem?t.iconMosaicItem.page===e.iconMosaicItem.page?0:t.iconMosaicItem.page-e.iconMosaicItem.page:t.iconMosaicItem&&!e.iconMosaicItem?1:!t.iconMosaicItem&&e.iconMosaicItem?-1:0}class gt extends j{constructor(t,e,s,i,n,r,o,c){if(super(t,e),this.type=3,this._markerMap=new Map,this._glyphMap=new Map,this._glyphBufferDataStorage=new Map,this._isIconSDF=!1,t.hasDataDrivenIcon!==s.isDataDriven())throw new Error("incompatible icon buffer");if(t.hasDataDrivenText!==n.isDataDriven())throw new Error("incompatible text buffer");this._iconVertexBuffer=s,this._iconIndexBuffer=i,this._textVertexBuffer=n,this._textIndexBuffer=r,this._placementEngine=o,this._workerTileHandler=c}get markerPageMap(){return this._markerMap}get glyphsPageMap(){return this._glyphMap}get symbolInstances(){return this._symbolInstances}getResources(t,s,i){const n=this.layer,r=this.zoom,o=n.hasDataDrivenIcon,c=n.hasDataDrivenText;t&&t.setExtent(this.layerExtent);const h=n.getLayoutProperty("icon-image"),a=n.getLayoutProperty("text-field"),l=[];let f,u,d,w,p,y,M,x,m,b,g=[1,1,1,1],k=1,I=1,_=[1,1,1,1],T=1,v=1;for(const A of this._features){const L=A.getGeometry(t);if(!L||0===L.length)continue;let N,S;h&&(N=n.getLayoutValue("icon-image",r,A),h.isDataDriven||(N=this._replaceKeys(N,A.values)),N&&(s.add(N),f=n.getLayoutValue("icon-rotate",r,A),u=n.getLayoutValue("icon-anchor",r,A),d=n.getLayoutValue("icon-offset",r,A)));let D=!1;if(a&&(S=n.getLayoutValue("text-field",r,A),S&&!a.isDataDriven&&(S=this._replaceKeys(S,A.values)),S)){switch(S=S.replace(/\\n/g,"\n"),n.getLayoutValue("text-transform",r,A)){case 2:S=S.toLowerCase();break;case 1:S=S.toUpperCase()}if(gt._bidiEngine.hasBidiChar(S)){let t;t="rtl"===gt._bidiEngine.checkContextual(S)?"IDNNN":"ICNNN",S=gt._bidiEngine.bidiTransform(S,t,"VLYSN"),D=!0}const t=S.length;if(t>0){b=n.getLayoutValue("text-font",r,A);for(const e of b){let s=i[e];s||(s=i[e]=new Set);for(let e=0;e<t;e++){const t=S.charCodeAt(e);s.add(t)}}w=n.getLayoutValue("text-rotate",r,A),p=n.getLayoutValue("text-anchor",r,A),y=n.getLayoutValue("text-offset",r,A),M=n.getLayoutValue("text-justify",r,A),x=n.getLayoutValue("text-letter-spacing",r,A),m=n.getLayoutValue("text-max-width",r,A)}}if(!N&&!S)continue;const P=n.getLayoutValue("icon-size",r,A),B=n.getLayoutValue("text-size",r,A);n.hasDataDrivenIconColor&&(g=n.getPaintValue("icon-color",r,A)),n.hasDataDrivenIconOpacity&&(k=n.getPaintValue("icon-opacity",r,A)),n.hasDataDrivenIconSize&&(I=P),n.hasDataDrivenTextColor&&(_=n.getPaintValue("text-color",r,A)),n.hasDataDrivenTextOpacity&&(T=n.getPaintValue("text-opacity",r,A)),n.hasDataDrivenTextSize&&(v=B);const F=n.getLayoutValue("symbol-sort-key",r,A),z={sprite:N,label:S,rtl:D,type:A.type,geometry:L,hash:(S?e(S):0)^(N?e(N):0),priority:F,iconSize:P,iconRotate:f,ddIconValues:o?{color:g,opacity:k,size:I}:null,iconAnchor:u,iconOffset:d,textSize:B,textRotate:w,ddTextValues:c?{color:_,opacity:T,size:v}:null,textAnchor:p,textOffset:y,textJustify:M,textLetterSpacing:x,textMaxWidth:m,textFontArray:b};l.push(z)}this._symbolFeatures=l}processFeatures(t){t&&t.setExtent(this.layerExtent);const e=this.layer,s=this.zoom,i=e.getLayoutValue("symbol-placement",s),n=0!==i,r=8*e.getLayoutValue("symbol-spacing",s),o=e.getLayoutProperty("icon-image"),c=e.getLayoutProperty("text-field"),h=o?new w(e,s,n):null,a=c?new p(e,s,n):null,f=this._workerTileHandler;let u;o&&(u=f.getSpriteItems()),this._iconIndexStart=3*this._iconIndexBuffer.index,this._textIndexStart=3*this._textIndexBuffer.index,this._iconIndexCount=0,this._textIndexCount=0,this._markerMap.clear(),this._glyphMap.clear();const d=[];let y=1;a&&a.size&&(y=a.size/D);const M=a?a.maxAngle*l:0,x=a?8*a.size:0;for(const t of this._symbolFeatures){let e,s;h&&u&&t.sprite&&(e=u[t.sprite],e&&e.sdf&&(this._isIconSDF=!0)),e&&(h.size=t.iconSize,h.rotate=t.iconRotate,h.offset=t.iconOffset);let o=0;const c=t.label;if(c){a.size=t.textSize,a.rotate=t.textRotate,a.anchor=t.textAnchor,a.fontArray=t.textFontArray,a.justify=t.textJustify,a.letterSpacing=t.textLetterSpacing,a.maxWidth=t.textMaxWidth,a.offset=t.textOffset;const e=n?a.keepUpright:a.writingMode&&a.writingMode.indexOf(1)>=0;let i=.5;switch(a.anchor){case 5:case 1:case 7:i=0;break;case 6:case 2:case 8:i=1}let r=.5;switch(a.anchor){case 5:case 3:case 6:r=0;break;case 7:case 4:case 8:r=1}let h=.5;switch(a.justify){case 0:h=i;break;case 1:h=0;break;case 3:h=1}const l=a.letterSpacing*D,u=n?0:a.maxWidth*D,d=a.lineHeight*D;let w,p;if(w=a.fontArray.map((t=>f.getGlyphItems(t))),p=new P(w,u,d,l,i,r,h),s=p.getShaping(c,t.rtl,e),s&&s.length>0){let t=1e30,e=-1e30;for(const i of s)t=Math.min(t,i.x),e=Math.max(e,i.x);o=(e-t+48)*y*8}}for(let c of t.geometry){const l=[];if(1===i){if(s&&s.length>0&&a&&a.size){const t=8*a.size*(2+Math.min(2,4*Math.abs(a.offset[1])));c=gt._smoothVertices(c,t)}gt._pushAnchors(l,c,r,o)}else 2===i?gt._pushCenterAnchor(l,c):3===t.type?gt._pushCentroid(l,c):l.push(new B(c[0].x,c[0].y));for(const i of l){if(i.x<0||i.x>4096||i.y<0||i.y>4096)continue;if(n&&o>0&&0===a.rotationAlignment&&!gt._honorsTextMaxAngle(c,i,o,M,x))continue;const r={shaping:s,line:c,iconMosaicItem:e,anchor:i,symbolFeature:t,textColliders:[],iconColliders:[],textVertexRanges:[],iconVertexRanges:[]};d.push(r),this._processFeature(r,h,a)}}}d.sort(bt),this._addPlacedGlyphs(),this._symbolInstances=d}serialize(){let t=13;t+=this.layerUIDs.length,t+=3*this.markerPageMap.size,t+=3*this.glyphsPageMap.size,t+=gt.symbolsSerializationLength(this._symbolInstances),t+=this._iconVertexBuffer.array.length,t+=this._iconIndexBuffer.array.length,t+=this._textVertexBuffer.array.length,t+=this._textIndexBuffer.array.length;let e=0;const s=new Uint32Array(t),i=new Int32Array(s.buffer),n=new Float32Array(s.buffer);s[e++]=this.type,s[e++]=this.layerUIDs.length;for(let t=0;t<this.layerUIDs.length;t++)s[e++]=this.layerUIDs[t];s[e++]=this._isIconSDF?1:0,s[e++]=this._iconVertexBuffer.isDataDriven()?1:0,s[e++]=this._textVertexBuffer.isDataDriven()?1:0,s[e++]=this.markerPageMap.size,this.markerPageMap.forEach((([t,i],n)=>{s[e++]=n,s[e++]=t,s[e++]=i})),s[e++]=this.glyphsPageMap.size,this.glyphsPageMap.forEach((([t,i],n)=>{s[e++]=n,s[e++]=t,s[e++]=i})),s[e++]=this._iconVertexBuffer.index/4,s[e++]=this._textVertexBuffer.index/4,e=gt.serializeSymbols(s,i,n,e,this._symbolInstances),s[e++]=this._iconVertexBuffer.array.length;for(let t=0;t<this._iconVertexBuffer.array.length;t++)i[e++]=this._iconVertexBuffer.array[t];s[e++]=this._iconIndexBuffer.array.length;for(let t=0;t<this._iconIndexBuffer.array.length;t++)s[e++]=this._iconIndexBuffer.array[t];s[e++]=this._textVertexBuffer.array.length;for(let t=0;t<this._textVertexBuffer.array.length;t++)i[e++]=this._textVertexBuffer.array[t];s[e++]=this._textIndexBuffer.array.length;for(let t=0;t<this._textIndexBuffer.array.length;t++)s[e++]=this._textIndexBuffer.array[t];return s.buffer}static symbolsSerializationLength(t){let e=0;e+=1;for(const s of t||[]){e+=4,e+=1;for(const t of s.textColliders)e+=10;for(const t of s.iconColliders)e+=10;e+=1,e+=2*s.textVertexRanges.length,e+=1,e+=2*s.iconVertexRanges.length}return e}static serializeSymbols(t,e,s,i,n){e[i++]=(n=n||[]).length;for(const t of n){e[i++]=t.anchor.x,e[i++]=t.anchor.y,e[i++]=t.symbolFeature.hash,e[i++]=t.symbolFeature.priority,e[i++]=t.textColliders.length+t.iconColliders.length;for(const n of t.textColliders)e[i++]=n.xTile,e[i++]=n.yTile,e[i++]=n.dxPixels,e[i++]=n.dyPixels,e[i++]=n.hard?1:0,e[i++]=n.partIndex,s[i++]=n.minLod,s[i++]=n.maxLod,e[i++]=n.width,e[i++]=n.height;for(const n of t.iconColliders)e[i++]=n.xTile,e[i++]=n.yTile,e[i++]=n.dxPixels,e[i++]=n.dyPixels,e[i++]=n.hard?1:0,e[i++]=n.partIndex,s[i++]=n.minLod,s[i++]=n.maxLod,e[i++]=n.width,e[i++]=n.height;e[i++]=t.textVertexRanges.length;for(const[s,n]of t.textVertexRanges)e[i++]=s,e[i++]=n;e[i++]=t.iconVertexRanges.length;for(const[s,n]of t.iconVertexRanges)e[i++]=s,e[i++]=n}return i}_replaceKeys(t,e){return t.replace(/{([^{}]+)}/g,(function(t,s){return s in e?e[s]:""}))}_processFeature(t,e,s){const i=t.line,n=t.iconMosaicItem,r=t.shaping,o=t.anchor,c=!!n;let h=!0;c&&(h=e.optional||!n);const a=r&&r.length>0;let l,f,u=!0;if(a&&(u=s.optional||!r||0===r.length),c&&(l=this._placementEngine.getIconPlacement(o,n,e)),(l||h)&&(a&&(f=this._placementEngine.getTextPlacement(o,r,i,s)),f||u)){if(l&&f||(u||h?u||f?h||l||(f=null):l=null:(l=null,f=null)),f&&(this._storePlacedGlyphs(t,f.shapes,this.zoom,s.rotationAlignment),f.textColliders)){t.textColliders=f.textColliders;for(const t of f.textColliders){t.minLod=Math.max(this.zoom+y(t.minLod),0),t.maxLod=Math.min(this.zoom+y(t.maxLod),25);const e=t.angle;if(e){const s=Math.cos(e),i=Math.sin(e),n=t.dxPixels*s-t.dyPixels*i,r=t.dxPixels*i+t.dyPixels*s,o=(t.dxPixels+t.width)*s-t.dyPixels*i,c=(t.dxPixels+t.width)*i+t.dyPixels*s,h=t.dxPixels*s-(t.dyPixels+t.height)*i,a=t.dxPixels*i+(t.dyPixels+t.height)*s,l=(t.dxPixels+t.width)*s-(t.dyPixels+t.height)*i,f=(t.dxPixels+t.width)*i+(t.dyPixels+t.height)*s,u=Math.min(n,o,h,l),d=Math.max(n,o,h,l),w=Math.min(r,c,a,f),p=Math.max(r,c,a,f);t.dxPixels=u,t.dyPixels=w,t.width=d-u,t.height=p-w}}}if(l&&(this._addPlacedIcons(t,l.shapes,this.zoom,n.page,1===e.rotationAlignment),l.iconColliders)){t.iconColliders=l.iconColliders;for(const t of l.iconColliders){t.minLod=Math.max(this.zoom+y(t.minLod),0),t.maxLod=Math.min(this.zoom+y(t.maxLod),25);const e=t.angle;if(e){const s=Math.cos(e),i=Math.sin(e),n=t.dxPixels*s-t.dyPixels*i,r=t.dxPixels*i+t.dyPixels*s,o=(t.dxPixels+t.width)*s-t.dyPixels*i,c=(t.dxPixels+t.width)*i+t.dyPixels*s,h=t.dxPixels*s-(t.dyPixels+t.height)*i,a=t.dxPixels*i+(t.dyPixels+t.height)*s,l=(t.dxPixels+t.width)*s-(t.dyPixels+t.height)*i,f=(t.dxPixels+t.width)*i+(t.dyPixels+t.height)*s,u=Math.min(n,o,h,l),d=Math.max(n,o,h,l),w=Math.min(r,c,a,f),p=Math.max(r,c,a,f);t.dxPixels=u,t.dyPixels=w,t.width=d-u,t.height=p-w}}}}}_addPlacedIcons(t,e,s,i,n){const r=t.symbolFeature.ddIconValues,o=Math.max(s-1,0),c=this._iconVertexBuffer,h=this._iconIndexBuffer,a=this._markerMap;for(const l of e){const e=n?0:Math.max(s+y(l.minzoom),o),f=n?25:Math.min(s+y(l.maxzoom),25);if(f<=e)continue;const u=l.tl,d=l.tr,w=l.bl,p=l.br,M=l.mosaicRect,x=l.labelAngle,m=l.minAngle,b=l.maxAngle,g=l.anchor,k=c.index,I=M.x,_=M.y,T=I+M.width,v=_+M.height,A=c.index;c.add(g.x,g.y,u.x,u.y,I,_,x,m,b,e,f,r),c.add(g.x,g.y,d.x,d.y,T,_,x,m,b,e,f,r),c.add(g.x,g.y,w.x,w.y,I,v,x,m,b,e,f,r),c.add(g.x,g.y,p.x,p.y,T,v,x,m,b,e,f,r),t.iconVertexRanges.length>0&&t.iconVertexRanges[0][0]+t.iconVertexRanges[0][1]===A?t.iconVertexRanges[0][1]+=4:t.iconVertexRanges.push([A,4]),h.add(k+0,k+1,k+2),h.add(k+1,k+2,k+3),a.has(i)?a.get(i)[1]+=6:a.set(i,[this._iconIndexStart+this._iconIndexCount,6]),this._iconIndexCount+=6}}_addPlacedGlyphs(){const t=this._textVertexBuffer,e=this._textIndexBuffer,s=this._glyphMap;this._glyphBufferDataStorage.forEach(((i,n)=>{for(const r of i){const i=t.index,o=r.symbolInstance,c=o.symbolFeature.ddTextValues,h=t.index;t.add(r.glyphAnchor[0],r.glyphAnchor[1],r.tl[0],r.tl[1],r.xmin,r.ymin,r.labelAngle,r.minAngle,r.maxAngle,r.minLod,r.maxLod,c),t.add(r.glyphAnchor[0],r.glyphAnchor[1],r.tr[0],r.tr[1],r.xmax,r.ymin,r.labelAngle,r.minAngle,r.maxAngle,r.minLod,r.maxLod,c),t.add(r.glyphAnchor[0],r.glyphAnchor[1],r.bl[0],r.bl[1],r.xmin,r.ymax,r.labelAngle,r.minAngle,r.maxAngle,r.minLod,r.maxLod,c),t.add(r.glyphAnchor[0],r.glyphAnchor[1],r.br[0],r.br[1],r.xmax,r.ymax,r.labelAngle,r.minAngle,r.maxAngle,r.minLod,r.maxLod,c),o.textVertexRanges.length>0&&o.textVertexRanges[0][0]+o.textVertexRanges[0][1]===h?o.textVertexRanges[0][1]+=4:o.textVertexRanges.push([h,4]),e.add(i+0,i+1,i+2),e.add(i+1,i+2,i+3),s.has(n)?s.get(n)[1]+=6:s.set(n,[this._textIndexStart+this._textIndexCount,6]),this._textIndexCount+=6}})),this._glyphBufferDataStorage.clear()}_storePlacedGlyphs(t,e,s,i){const n=Math.max(s-1,0),r=1===i;let o,c,h,a,l,f,u,d,w,p,M;for(const i of e)o=r?0:Math.max(s+y(i.minzoom),n),c=r?25:Math.min(s+y(i.maxzoom),25),c<=o||(h=i.tl,a=i.tr,l=i.bl,f=i.br,u=i.labelAngle,d=i.minAngle,w=i.maxAngle,p=i.anchor,M=i.mosaicRect,this._glyphBufferDataStorage.has(i.page)||this._glyphBufferDataStorage.set(i.page,[]),this._glyphBufferDataStorage.get(i.page).push({glyphAnchor:[p.x,p.y],tl:[h.x,h.y],tr:[a.x,a.y],bl:[l.x,l.y],br:[f.x,f.y],xmin:M.x,ymin:M.y,xmax:M.x+M.width,ymax:M.y+M.height,labelAngle:u,minAngle:d,maxAngle:w,minLod:o,maxLod:c,placementLod:n,symbolInstance:t}))}static _pushAnchors(t,e,s,i){s+=i;let n=0;const r=e.length-1;for(let t=0;t<r;t++)n+=b.distance(e[t],e[t+1]);let o=i||s;if(o*=.5,n<=o)return;const c=o/n;let h=0,a=-(s=n/Math.max(Math.round(n/s),1))/2;const l=e.length-1;for(let i=0;i<l;i++){const n=e[i],r=e[i+1],o=r.x-n.x,l=r.y-n.y,f=Math.sqrt(o*o+l*l);let u;for(;a+s<h+f;){a+=s;const e=(a-h)/f,d=M(n.x,r.x,e),w=M(n.y,r.y,e);void 0===u&&(u=Math.atan2(l,o)),t.push(new B(d,w,u,i,c))}h+=f}}static _pushCenterAnchor(t,e){let s=0;const i=e.length-1;for(let t=0;t<i;t++)s+=b.distance(e[t],e[t+1]);const n=s/2;let r=0;const o=e.length-1;for(let s=0;s<o;s++){const i=e[s],o=e[s+1],c=o.x-i.x,h=o.y-i.y,a=Math.sqrt(c*c+h*h);if(n<r+a){const e=(n-r)/a,l=M(i.x,o.x,e),f=M(i.y,o.y,e),u=Math.atan2(h,c);return void t.push(new B(l,f,u,s,0))}r+=a}}static _deviation(t,e,s){return Math.atan2((e.x-t.x)*(s.y-e.y)-(e.y-t.y)*(s.x-e.x),(e.x-t.x)*(s.x-e.x)+(e.y-t.y)*(s.y-e.y))}static _honorsTextMaxAngle(t,e,s,i,n){let r=0;const o=s/2;let c=new b(e.x,e.y),h=e.segment+1;for(;r>-o;){if(--h,h<0)return!1;r-=b.distance(t[h],c),c=t[h]}r+=b.distance(t[h],t[h+1]);const a=[];let l=0;const f=t.length;for(;r<o;){const e=t[h];let s,o=h;do{if(++o,o===f)return!1;s=t[o]}while(s.isEqual(e));let c,u=o;do{if(++u,u===f)return!1;c=t[u]}while(c.isEqual(s));const d=this._deviation(e,s,c);for(a.push({deviation:d,distToAnchor:r}),l+=d;r-a[0].distToAnchor>n;)l-=a.shift().deviation;if(Math.abs(l)>i)return!1;r+=b.distance(s,c),h=o}return!0}static _smoothVertices(t,e){if(e<=0)return t;let s=t.length;if(s<3)return t;const i=[];let n=0,r=0;i.push(0);for(let e=1;e<s;e++){const s=b.distance(t[e],t[e-1]);s>0&&(n+=s,i.push(n),r++,r!==e&&(t[r]=t[e]))}if(s=r+1,s<3)return t;e=Math.min(e,.2*n);const o=t[0].x,c=t[0].y,h=t[s-1].x,a=t[s-1].y,l=b.sub(t[0],t[1]);l.normalize(),t[0].x+=e*l.x,t[0].y+=e*l.y,l.assignSub(t[s-1],t[s-2]),l.normalize(),t[s-1].x+=e*l.x,t[s-1].y+=e*l.y,i[0]-=e,i[s-1]+=e;const f=[];f.push(new b(o,c));const u=1e-6,d=.5*e;for(let n=1;n<s-1;n++){let r=0,o=0,c=0;for(let s=n-1;s>=0;s--){const h=d+i[s+1]-i[n];if(h<0)break;const a=i[s+1]-i[s],l=i[n]-i[s]<d?1:h/a;if(l<u)break;const f=l*l,w=l*h-.5*f*a,p=l*a/e,y=t[s+1],M=t[s].x-y.x,x=t[s].y-y.y;r+=p/w*(y.x*l*h+.5*f*(h*M-a*y.x)-f*l*a*M/3),o+=p/w*(y.y*l*h+.5*f*(h*x-a*y.y)-f*l*a*x/3),c+=p}for(let h=n+1;h<s;h++){const s=d-i[h-1]+i[n];if(s<0)break;const a=i[h]-i[h-1],l=i[h]-i[n]<d?1:s/a;if(l<u)break;const f=l*l,w=l*s-.5*f*a,p=l*a/e,y=t[h-1],M=t[h].x-y.x,x=t[h].y-y.y;r+=p/w*(y.x*l*s+.5*f*(s*M-a*y.x)-f*l*a*M/3),o+=p/w*(y.y*l*s+.5*f*(s*x-a*y.y)-f*l*a*x/3),c+=p}f.push(new b(r/c,o/c))}return f.push(new b(h,a)),t[0].x=o,t[0].y=c,t[s-1].x=h,t[s-1].y=a,f}static _pushCentroid(t,e){const s=4096,i=4096,n=e.length-1;let r=0,o=0,c=0,h=e[0].x,a=e[0].y;h>s&&(h=s),h<0&&(h=0),a>i&&(a=i),a<0&&(a=0);for(let t=1;t<n;t++){let n=e[t].x,l=e[t].y,f=e[t+1].x,u=e[t+1].y;n>s&&(n=s),n<0&&(n=0),l>i&&(l=i),l<0&&(l=0),f>s&&(f=s),f<0&&(f=0),u>i&&(u=i),u<0&&(u=0);const d=(n-h)*(u-a)-(f-h)*(l-a);r+=d*(h+n+f),o+=d*(a+l+u),c+=d}r/=3*c,o/=3*c,isNaN(r)||isNaN(o)||t.push(new B(r,o))}}gt._bidiEngine=new v;const kt=new Float32Array(1),It=new Uint32Array(kt.buffer);class _t extends ut{constructor(t){super(t?20:12),this._isDataDriven=t}isDataDriven(){return this._isDataDriven}add(t,e,s,i,n,r,o,c){const h=this.array;let a=ut.i1616to32(t,e);if(h.push(a),a=ut.i8888to32(Math.round(31*s),Math.round(31*i),Math.round(31*n),Math.round(31*r)),h.push(a),a=ut.i1616to32(o,0),h.push(a),this._isDataDriven){if(!c)throw new Error("Expecting data driven values.");const t=c.color,e=t[3]*c.opacity*255;h.push(ut.i8888to32(t[0]*e,t[1]*e,t[2]*e,e)),kt[0]=c.size,h.push(It[0])}}}class Tt extends ut{constructor(t){super(t?8:4),this._isDataDriven=t}isDataDriven(){return this._isDataDriven}add(t,e,s){const i=this.array;if(i.push(ut.i1616to32(t,e)),this._isDataDriven){if(!s)throw new Error("Expecting data driven values.");const t=s.color,e=t[3]*s.opacity*255;i.push(ut.i8888to32(t[0]*e,t[1]*e,t[2]*e,e))}}}class vt extends ut{constructor(t){super(t?12:8),this._isDataDriven=t}isDataDriven(){return this._isDataDriven}add(t,e,s,i,n,r,o){const c=this.array,h=this.index;let a=ut.i1616to32(t,e);if(c.push(a),a=ut.i8888to32(Math.round(15*s),Math.round(15*i),n,r),c.push(a),this._isDataDriven){if(!o)throw new Error("Expecting data driven values.");const t=o.color,e=t[3]*o.opacity*255;c.push(ut.i8888to32(t[0]*e,t[1]*e,t[2]*e,e))}return h}}class At extends ut{constructor(t){super(t?24:16),this._isDataDriven=t}isDataDriven(){return this._isDataDriven}add(t,e,s,i,n,r,o,c,h,a,l,u){const d=this.array;let w=ut.i1616to32(t,e);if(d.push(w),w=ut.i1616to32(Math.round(8*s),Math.round(8*i)),d.push(w),w=ut.i8888to32(n/4,r/4,c,h),d.push(w),w=ut.i8888to32(0,f(o),10*a,Math.min(10*l,255)),d.push(w),this._isDataDriven){if(!u)throw new Error("Expecting data driven values.");const t=u.color,e=t[3]*u.opacity*255;d.push(ut.i8888to32(t[0]*e,t[1]*e,t[2]*e,e)),kt[0]=u.size,d.push(It[0])}}}class Lt extends ut{constructor(){super(16)}add(t,e,s,i,n,r,o,c,h,a,l){const f=this.array;let u=ut.i1616to32(2*t+s,2*e+i);f.push(u);const d=r[3]*o*255;u=ut.i8888to32(r[0]*d,r[1]*d,r[2]*d,d),f.push(u);const w=a[3]*l*255;u=ut.i8888to32(a[0]*w,a[1]*w,a[2]*w,w),f.push(u),u=ut.i8888to32(Math.min(32*c,255),Math.min(4*h,255),Math.min(n,255),0),f.push(u)}}class Nt{constructor(t,e,s,i,n){if(this._pbfTiles={},this._tileClippers={},this._client=s,this._tile=e,n){this._styleLayerUIDs=new Set;for(const t of n)this._styleLayerUIDs.add(t)}this._styleRepository=i,this._layers=this._styleRepository.layers;const[r,o,h]=e.tileKey.split("/").map(parseFloat);this._level=r;const a=Math.max(8,Math.round(1*this._level)-8);for(const e of Object.keys(t)){const s=t[e];if(this._pbfTiles[e]=new c(new Uint8Array(s.protobuff),new DataView(s.protobuff)),s.refKey){const[t]=s.refKey.split("/").map(parseFloat),i=r-t;if(i>0){const t=(1<<i)-1;this._tileClippers[e]=new A(i,o&t,h&t,8,a)}}this._tileClippers[e]||(this._tileClippers[e]=new L)}}_canParseStyleLayer(t){return!this._styleLayerUIDs||this._styleLayerUIDs.has(t)}async parse(t){const e=this._initialize(t),{returnedBuckets:n}=e;this._processLayers(e),this._linkReferences(e),this._filterFeatures(e);const r=new Set,o={};for(const t of n)3===t.type&&t.getResources(t.tileClipper,r,o);if(this._tile.status===N.INVALID)return s([]);const c=this._fetchResources(r,o,t);return i(c).then((()=>this._processFeatures(e.returnedBuckets)))}_initialize(t){return{signal:t&&t.signal,sourceNameToTileData:this._parseTileData(this._pbfTiles),layers:this._layers,zoom:this._level,sourceNameToTileClipper:this._tileClippers,sourceNameToUniqueSourceLayerBuckets:{},sourceNameToUniqueSourceLayers:{},returnedBuckets:[],layerIdToBucket:{},referencerUIDToReferencedId:new Map}}_processLayers(t){const{sourceNameToTileData:e,layers:s,zoom:i,sourceNameToTileClipper:n,sourceNameToUniqueSourceLayerBuckets:r,sourceNameToUniqueSourceLayers:o,returnedBuckets:c,layerIdToBucket:h,referencerUIDToReferencedId:a}=t;for(let t=s.length-1;t>=0;t--){const l=s[t];if(!this._canParseStyleLayer(l.uid)||l.minzoom&&i<Math.floor(l.minzoom)||l.maxzoom&&i>=l.maxzoom||0===l.type)continue;if(!e[l.source]||!n[l.source])continue;const f=n[l.source],u=l.sourceLayer,d=e[l.source][u];if(d){let t=o[l.source];if(t||(t=o[l.source]=new Set),t.add(l.sourceLayer),l.refLayerId)a.set(l.uid,l.refLayerId);else{const t=this._createBucket(l);if(t){t.layerUIDs=[l.uid],t.layerExtent=d.extent,t.tileClipper=f;let e=r[l.source];e||(e=r[l.source]={});let s=e[u];s||(s=e[u]=[]),s.push(t),c.push(t),h[l.id.toLowerCase()]=t}}}}}_linkReferences(t){const{layerIdToBucket:e,referencerUIDToReferencedId:s}=t;s.forEach(((t,s)=>{t=t.toLowerCase(),e[t]&&e[t].layerUIDs.push(s)}))}_filterFeatures(t){const{signal:e,sourceNameToTileData:s,sourceNameToUniqueSourceLayerBuckets:i,sourceNameToUniqueSourceLayers:r}=t,o=10*this._level,c=10*(this._level+1),h=[],a=[];for(const t of Object.keys(r))r[t].forEach((e=>{h.push(e),a.push(t)}));for(let t=0;t<h.length;t++){const r=a[t],l=h[t];if(!s[r]||!i[r])continue;const f=s[r][l],u=i[r][l];if(!u||0===u.length)continue;if(n(e))return;const d=f.getData();for(;d.nextTag(2);){const t=d.getMessage(),e=new O(t,f);t.release();const s=e.values;if(s){const t=s._minzoom;if(t&&t>=c)continue;const e=s._maxzoom;if(e&&e<=o)continue}for(const t of u)t.pushFeature(e)}}}_fetchResources(t,e,s){const i=[],n=this._tile.getWorkerTileHandler();let r,o;t.size>0&&(r=n.fetchSprites(t,this._client,s),i.push(r));for(const t in e){const r=e[t];r.size>0&&(o=n.fetchGlyphs(this._tile.tileKey,t,r,this._client,s),i.push(o))}return i}_processFeatures(t){const e=t.filter((t=>t.hasFeatures()));for(const t of e)t.processFeatures(t.tileClipper);return e}_parseTileData(t){const e={};for(const s of Object.keys(t)){const i=t[s],n={};for(;i.next();)switch(i.tag()){case 3:{const t=i.getMessage(),e=new mt(t);t.release(),n[e.name]=e;break}default:i.skip()}e[s]=n}return e}_createBucket(t){switch(t.type){case 0:return null;case 1:return this._createFillBucket(t);case 2:return this._createLineBucket(t);case 4:return this._createCircleBucket(t);case 3:return this._createSymbolBucket(t)}}_createFillBucket(t){return new ft(t,this._level,new Tt(t.hasDataDrivenFill),new dt,new vt(t.hasDataDrivenOutline),new dt)}_createLineBucket(t){return new xt(t,this._level,new _t(t.hasDataDrivenLine),new dt)}_createCircleBucket(t){return new C(t,this._level,new Lt,new dt)}_createSymbolBucket(t){const e=this._tile;return new gt(t,this._level,new At(t.hasDataDrivenIcon),new dt,new At(t.hasDataDrivenText),new dt,e.placementEngine,e.getWorkerTileHandler())}}class St{constructor(t,e,s,i){this.status=N.INITIALIZED,this.placementEngine=new U,this.tileKey=t,this.refKeys=e,this._workerTileHandler=s,this._styleRepository=i}release(){this.tileKey="",this.refKeys=null,this.status=N.INITIALIZED,this._workerTileHandler=null}async parse(t,e,s){const i=s&&s.signal;if(r(i)){const t=()=>{i.removeEventListener("abort",t),this.status=N.INVALID};i.addEventListener("abort",t)}let n;try{n=await this._parse(t,s)}catch(t){if(o(t))throw t;return{result:[],transferList:[]}}this.status=N.READY;const c=[];for(const t of n){const e=t.serialize();c.push(e)}return{result:c,transferList:c.length<=e&&c}}setObsolete(){this.status=N.INVALID}getLayers(){return this._workerTileHandler.getLayers()}getWorkerTileHandler(){return this._workerTileHandler}async _parse(t,e){const s=t.sourceName2DataAndRefKey;return 0===Object.keys(s).length?[]:(this.status=N.MODIFIED,new Nt(s,this,e.client,this._styleRepository,t.styleLayerUIDs).parse(e))}}export default class{constructor(){this._spriteInfo={},this._glyphInfo={}}reset(){return this._spriteInfo={},this._glyphInfo={},s()}getLayers(){var t;return null==(t=this._styleRepository)?void 0:t.layers}async createTileAndParse(t,e){const{key:s}=t,i={};for(const e of Object.keys(t.sourceName2DataAndRefKey))i[e]=t.sourceName2DataAndRefKey[e].refKey;const n=new St(s,i,this,this._styleRepository);try{return await n.parse(t,this._vectorTileLayerMaxBuffers,e)}catch(t){if(n.setObsolete(),n.release(),!o(t))throw t;return null}}updateStyle(t){if(!t||0===t.length||!this._styleRepository)return;const e=this._styleRepository;for(const s of t){const t=s.data;switch(s.type){case 0:e.setPaintProperties(t.layer,t.paint);break;case 1:e.setLayoutProperties(t.layer,t.layout);break;case 3:e.deleteStyleLayer(t.layerName);break;case 2:e.setStyleLayer(t.layer,t.index)}}}setStyle(t){this._styleRepository=new x(t.style),this._spriteInfo={},this._glyphInfo={},this._vectorTileLayerMaxBuffers=t.vectorTileLayerMaxBuffers}fetchSprites(t,e,i){const n=[],r=this._spriteInfo;return t.forEach((t=>{void 0===r[t]&&n.push(t)})),0===n.length?s():e.invoke("getSprites",n,{signal:i&&i.signal}).then((t=>{for(const e in t)r[e]=t[e]}))}getSpriteItems(){return this._spriteInfo}fetchGlyphs(t,e,i,n,r){const o=[];let c=this._glyphInfo[e];return c?i.forEach((t=>{c[t]||o.push(t)})):(c=this._glyphInfo[e]=[],i.forEach((t=>o.push(t)))),0===o.length?s():n.invoke("getGlyphs",{tileID:t,font:e,codePoints:o},r).then((t=>{for(let e=0;e<t.length;e++)t[e]&&(c[e]=t[e])}))}getGlyphItems(t){return this._glyphInfo[t]}}