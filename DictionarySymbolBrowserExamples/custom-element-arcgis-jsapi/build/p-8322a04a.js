import{s as t,q as s,r as i,v as e,ao as r,o as n,ap as h,l as o,aq as a,Y as c,ar as l,i as u,ai as f,as as d,N as M,at as m,au as S,av as y}from"./p-dc4230e0.js";import{t as C}from"./p-7fc65112.js";class b{constructor(){this.setIdentity()}getAngle(){return(null==this.rz||0===this.rz&&1!==this.rz_c&&0!==this.rz_s)&&(this.rz=Math.atan2(this.rz_s,this.rz_c)),this.rz}setIdentity(){this.tx=0,this.ty=0,this.tz=0,this.s=1,this.rx=0,this.ry=0,this.rz=0,this.rz_c=1,this.rz_s=0}setTranslate(t,s){this.tx=t,this.ty=s}setTranslateZ(t){this.tz=t}setRotateCS(t,s){this.rz=void 0,this.rz_c=t,this.rz_s=s}setRotate(t){this.rz=t,this.rz_c=void 0,this.rz_s=void 0}setRotateY(t){this.ry=t}setScale(t){this.s=t}setMeasure(t){this.m=t}}class k{constructor(t){this._geometry=t}next(){const t=this._geometry;return this._geometry=null,t}}function p(r){const n=t(r);return function(t){t&&(s(t)?x(t.rings):i(t)?x(t.paths):e(t)&&I(t.points))}(n),n}function g(t){if(t)for(let s=t.length-1;s>0;--s)t[s][0]-=t[s-1][0],t[s][1]-=t[s-1][1]}function w(t){if(t)for(const s of t)g(s)}function I(t){if(t){const s=t.length;for(let i=1;i<s;++i)t[i][0]+=t[i-1][0],t[i][1]+=t[i-1][1]}}function x(t){if(t)for(const s of t)I(s)}function v(t){t&&(s(t)?w(t.rings):i(t)?w(t.paths):e(t)&&g(t.points))}function P(t){if(t)for(const s of t)O(s)}function O(t){t&&t.reverse()}function L(t,s,i){return[t[0]+(s[0]-t[0])*i,t[1]+(s[1]-t[1])*i]}function F(t){return t[4]}function A(t,s){t[4]=s}class N{constructor(t,e,n,h){this.acceptPolygon=e,this.acceptPolyline=n,this.geomUnitsPerPoint=h,this.pathCount=-1,this.pathIndex=-1,this.iteratePath=!1,t&&(s(t)?e&&(this.multiPath=t.rings,this.isClosed=!0):i(t)?n&&(this.multiPath=t.paths,this.isClosed=!1):r(t)&&e&&(this.multiPath=z(t).rings,this.isClosed=!0),this.multiPath&&(this.pathCount=this.multiPath.length)),this.internalPlacement=new b}next(){if(!this.multiPath)return null;for(;this.iteratePath||this.pathIndex<this.pathCount-1;){this.iteratePath||this.pathIndex++;const t=this.processPath(this.multiPath[this.pathIndex]);if(t)return t}return this.pathCount=-1,this.pathIndex=-1,this.multiPath=null,null}}class R{constructor(t,s,i,e){this.inputGeometries=t,this.acceptPolygon=s,this.acceptPolyline=i,this.geomUnitsPerPoint=e,this.pathCount=-1,this.pathIndex=-1,this.iteratePath=!1}next(){for(;;){if(!this.multiPath){let t=this.inputGeometries.next();for(;t;){if(s(t)?this.acceptPolygon&&(this.multiPath=t.rings,this.isClosed=!0):i(t)?this.acceptPolyline&&(this.multiPath=t.paths,this.isClosed=!1):r(t)&&this.acceptPolygon&&(this.multiPath=z(t).rings,this.isClosed=!0),this.multiPath){this.pathCount=this.multiPath.length,this.pathIndex=-1;break}t=this.inputGeometries.next()}if(!this.multiPath)return null}for(;this.iteratePath||this.pathIndex<this.pathCount-1;){this.iteratePath||this.pathIndex++;const t=this.processPath(this.multiPath[this.pathIndex]);if(t)return t}this.pathCount=-1,this.pathIndex=-1,this.multiPath=null}}}function z(t){return{rings:[[[t.xmin,t.ymin],[t.xmin,t.ymax],[t.xmax,t.ymax],[t.xmax,t.ymin],[t.xmin,t.ymin]]]}}class H{static local(){return null===H.instance&&(H.instance=new H),H.instance}execute(t,s,i){return new J(t,s,i)}}H.instance=null;class J{constructor(t,s,i){this._inputGeometries=t,this._angleTolerance=void 0!==s.angleTolerance?s.angleTolerance:120,this._maxCosAngle=Math.cos((1-Math.abs(this._angleTolerance)/180)*Math.PI)}next(){let e=this._inputGeometries.next();for(;e;){if(s(e)){this._isClosed=!0;const s=t(e);return this._processMultipath(s.rings),s}if(i(e)){this._isClosed=!1;const s=t(e);return this._processMultipath(s.paths),s}if(r(e)){if(this._maxCosAngle)return e;this._isClosed=!0;const t=[[e.xmin,e.ymin],[e.xmin,e.ymax],[e.xmax,e.ymax],[e.xmax,e.ymin],[e.xmin,e.ymin]];return this._processPath(t),{rings:[t]}}e=this._inputGeometries.next()}return null}_processMultipath(t){if(t)for(const s of t)this._processPath(s)}_processPath(t){if(t){let s,i,e,r,n,h,o=t.length,a=t[0];this._isClosed&&++o;for(let c=1;c<o;++c){let l;l=this._isClosed&&c===o-1?t[0]:t[c];const u=l[0]-a[0],f=l[1]-a[1],d=Math.sqrt(u*u+f*f);c>1&&d>0&&e>0&&(s*u+i*f)/d/e<=this._maxCosAngle&&A(a,1),1===c&&(r=u,n=f,h=d),d>0&&(a=l,s=u,i=f,e=d)}this._isClosed&&e>0&&h>0&&(s*r+i*n)/h/e<=this._maxCosAngle&&A(t[0],1)}}}class _{constructor(){this._path=[]}path(){return this._path}addPath(t,s){s||t.reverse(),Array.prototype.push.apply(this._path,t),s||t.reverse()}static mergePath(t,s){s&&Array.prototype.push.apply(t,s)}startPath(t){this._path.push(t)}lineTo(t){this._path.push(t)}close(){const t=this._path;t.length>1&&(t[0][0]===t[t.length-1][0]&&t[0][1]===t[t.length-1][1]||t.push([t[0][0],t[0][1]]))}}class E{constructor(t=0,s=!1){}normalize(t){const s=Math.sqrt(t[0]*t[0]+t[1]*t[1]);t[0]/=s,t[1]/=s}calculateLength(t,s){const i=s[0]-t[0],e=s[1]-t[1];return Math.sqrt(i*i+e*e)}calculateSegLength(t,s){return this.calculateLength(t[s],t[s+1])}calculatePathLength(t){let s=0;const i=t?t.length:0;for(let e=0;e<i-1;++e)s+=this.calculateSegLength(t,e);return s}calculatePathArea(t){let s=0;const i=t?t.length:0;for(let e=0;e<i-1;++e)s+=(t[e+1][0]-t[e][0])*(t[e+1][1]+t[e][1]);return s/2}getCoord2D(t,s,i){return[t[0]+(s[0]-t[0])*i,t[1]+(s[1]-t[1])*i]}getSegCoord2D(t,s,i){return this.getCoord2D(t[s],t[s+1],i)}getAngle(t,s,i){return Math.atan2(s[1]-t[1],s[0]-t[0])}getSegAngle(t,s,i){return this.getAngle(t[s],t[s+1],i)}getAngleCS(t,s,i){const e=s[0]-t[0],r=s[1]-t[1],n=Math.sqrt(e*e+r*r);return n>0?[e/n,r/n]:[1,0]}getSegAngleCS(t,s,i){return this.getAngleCS(t[s],t[s+1],i)}cut(t,s,i,e){return[i<=0?t[s]:this.getSegCoord2D(t,s,i),e>=1?t[s+1]:this.getSegCoord2D(t,s,e)]}addSegment(t,s,i){i&&t.push(s[0]),t.push(s[1])}getSubCurve(t,s,i){const e=[];return this.appendSubCurve(e,t,s,i)?e:null}appendSubCurve(t,s,i,e){const r=s?s.length-1:0;let n=0,h=!0,o=0;for(;o<r;){const r=this.calculateSegLength(s,o);if(0!==r){if(h){if(n+r>i){let a=1,c=!1;n+r>=e&&(a=(e-n)/r,c=!0);const l=this.cut(s,o,(i-n)/r,a);if(l&&this.addSegment(t,l,h),c)break;h=!1}}else{if(n+r>e){const i=this.cut(s,o,0,(e-n)/r);i&&this.addSegment(t,i,h);break}this.addSegment(t,[s[o],s[o+1]],h)}n+=r,++o}else++o}return!0}getCIMPointAlong(t,s){const i=t?t.length-1:0;let e=0,r=-1;for(;r<i;){++r;const i=this.calculateSegLength(t,r);if(0!==i){if(e+i>s)return this.getCoord2D(t[r],t[r+1],(s-e)/i);e+=i}}return null}isEmpty(t,s){if(!t||t.length<=1)return!0;const i=t?t.length-1:0;let e=-1;for(;e<i;){if(++e,t[e+1][0]!==t[e][0]||t[e+1][1]!==t[e][1])return!1;if(s&&t[e+1][2]!==t[e][2])return!1}return!0}offset(t,s,i,e,r){if(!t||t.length<2)return null;let n=t.length;const h=t[0][0]===t[n-1][0]&&t[0][1]===t[n-1][1];if(h){if(t.length<3)return null;--n}const o=[];let a=h?t[n-1]:null,c=t[0];for(let r=0;r<n;r++){const l=r===n-1?h?t[0]:null:t[r+1];if(a)if(l){const t=[l[0]-c[0],l[1]-c[1]];this.normalize(t);const r=[c[0]-a[0],c[1]-a[1]];this.normalize(r);const n=r[0]*t[1]-r[1]*t[0],h=r[0]*t[0]+r[1]*t[1];if(n>=0==s<=0){const i=[t[0]-r[0],t[1]-r[1]];this.normalize(i);const e=Math.sqrt((1+h)/2),n=-Math.abs(s)/e;o.push([c[0]-i[0]*n,c[1]-i[1]*n])}else switch(i){case"Mitered":{const i=Math.sqrt((1+h)/2);if(i>0&&1/i<e){const e=[t[0]-r[0],t[1]-r[1]];this.normalize(e);const n=Math.abs(s)/i;o.push([c[0]-e[0]*n,c[1]-e[1]*n]);break}}case"Bevelled":o.push([c[0]+r[1]*s,c[1]-r[0]*s]),o.push([c[0]+t[1]*s,c[1]-t[0]*s]);break;case"Rounded":{o.push([c[0]+r[1]*s,c[1]-r[0]*s]);const i=5,e=1/i;let n=e;for(let h=1;h<i;h++,n+=e){const i=[r[1]*(1-n)+t[1]*n,-r[0]*(1-n)-t[0]*n];this.normalize(i),o.push([c[0]+i[0]*s,c[1]+i[1]*s])}o.push([c[0]+t[1]*s,c[1]-t[0]*s]);break}case"Square":default:if(n<0)o.push([c[0]+(r[1]+r[0])*s,c[1]+(r[1]-r[0])*s]),o.push([c[0]+(t[1]-t[0])*s,c[1]-(t[0]+t[1])*s]);else{const i=Math.sqrt((1+Math.abs(h))/2),e=[t[0]-r[0],t[1]-r[1]];this.normalize(e);const n=s/i;o.push([c[0]-e[0]*n,c[1]-e[1]*n])}}}else{const t=[c[0]-a[0],c[1]-a[1]];this.normalize(t),o.push([c[0]+t[1]*s,c[1]-t[0]*s])}else{const t=[l[0]-c[0],l[1]-c[1]];this.normalize(t),o.push([c[0]+t[1]*s,c[1]-t[0]*s])}a=c,c=l}return h&&o.push([o[0][0],o[0][1]]),o}}const G=1.7320508075688772;class D{static local(){return null===D.instance&&(D.instance=new D),D.instance}execute(t,s,i){return new X(t,s,i)}}D.instance=null;class X extends R{constructor(t,s,i){super(t,!1,!0),this._curveHelper=new E,this._width=(void 0!==s.width?s.width:5)*i,this._arrowType=void 0!==s.geometricEffectArrowType?s.geometricEffectArrowType:"OpenEnded",this._offsetFlattenError=.03*i}processPath(t){switch(this._arrowType){case"OpenEnded":default:return this._constructSimpleArrow(t,!0);case"Block":return this._constructSimpleArrow(t,!1);case"Crossed":return this._constructCrossedArrow(t)}}_constructSimpleArrow(t,s){const i=this._curveHelper.calculatePathLength(t);let e=this._width;i<2*e&&(e=i/2);const r=this._curveHelper.getSubCurve(t,0,i-e);if(!r)return null;const n=e/2;if(this._curveHelper.isEmpty(r,!1))return null;const h=this._constructOffset(r,-n);if(!h)return null;const o=this._constructOffset(r,n);if(!o)return null;const a=this._constructArrowBasePoint(h,-n/2);if(!a)return null;const c=this._constructArrowBasePoint(o,n/2);if(!c)return null;const l=t[t.length-1];s||(this._makeControlPoint(o,!0),this._makeControlPoint(h,!0));const u=new _;return u.addPath(o,!0),u.lineTo(c),this._makeControlPoint(u.path()),u.lineTo(l),this._makeControlPoint(u.path()),u.lineTo(a),this._makeControlPoint(u.path()),u.addPath(h,!1),s?{paths:[u.path()]}:(u.close(),{rings:[u.path()]})}_constructCrossedArrow(t){const s=this._curveHelper.calculatePathLength(t);let i=this._width;s<i*(1+G+1)&&(i=s/(1+G+1));const e=this._curveHelper.getSubCurve(t,0,s-i*(1+G));if(!e)return null;const r=i/2;if(this._curveHelper.isEmpty(e,!1))return null;const n=this._constructOffset(e,r);if(!n)return null;const h=this._constructOffset(e,-r);if(!h)return null;const o=this._curveHelper.getSubCurve(t,0,s-i);if(!o)return null;if(this._curveHelper.isEmpty(o,!1))return null;const a=this._constructOffset(o,r);if(!a)return null;const c=this._constructOffset(o,-r);if(!c)return null;const l=a[a.length-1],u=this._constructArrowBasePoint(a,r/2);if(!u)return null;const f=c[c.length-1],d=this._constructArrowBasePoint(c,-r/2);if(!d)return null;const M=t[t.length-1];this._makeControlPoint(n,!1),this._makeControlPoint(h,!1);const m=new _;return m.addPath(n,!0),this._makeControlPoint(m.path()),m.lineTo(f),m.lineTo(d),this._makeControlPoint(m.path()),m.lineTo(M),this._makeControlPoint(m.path()),m.lineTo(u),this._makeControlPoint(m.path()),m.lineTo(l),this._makeControlPoint(m.path()),m.addPath(h,!1),{paths:[m.path()]}}_constructOffset(t,s){return this._curveHelper.offset(t,s,"Rounded",4,this._offsetFlattenError)}_constructArrowBasePoint(t,s){if(!t||t.length<2)return null;const i=t[t.length-2],e=t[t.length-1],r=[e[0]-i[0],e[1]-i[1]];return this._curveHelper.normalize(r),[e[0]+r[1]*s,e[1]-r[0]*s]}_makeControlPoint(t,s=!1){A(s?t[0]:t[t.length-1],1)}}class V{static local(){return null===V.instance&&(V.instance=new V),V.instance}execute(t,s,i){return new $(t,s,i)}}V.instance=null;class ${constructor(t,s,i){this._inputGeometries=t,this._curveHelper=new E,this._size=(void 0!==s.size?s.size:1)*i,this._offsetFlattenError=.03*i}next(){let t=this._inputGeometries.next();for(;t;){if(r(t))if(this._size>0){const s=this._curveHelper.offset([[t.xmin,t.ymin],[t.xmin,t.ymax],[t.xmax,t.ymax],[t.xmax,t.ymin],[t.xmin,t.ymin]],this._size,"Rounded",4,this._offsetFlattenError);if(s)return{rings:[s]}}else{if(!(this._size<0))return t;if(Math.min(t.xmax-t.xmin,t.ymax-t.ymin)+2*this._size>0)return{xmin:t.xmin-this._size,xmax:t.xmax+this._size,ymin:t.ymin-this._size,ymax:t.ymax+this._size}}if(s(t)){if(0===this._size)return t;const s=[];for(const i of t.rings){const t=this._curveHelper.offset(i,this._size,"Rounded",4,this._offsetFlattenError);t&&s.push(t)}if(s.length)return{rings:s}}if(i(t)&&this._size>0){const s=[];for(const i of t.paths)if(i&&i.length>1){const t=this._curveHelper.offset(i,this._size,"Rounded",4,this._offsetFlattenError),e=this._curveHelper.offset(i,-this._size,"Rounded",4,this._offsetFlattenError);if(t&&e){for(let s=e.length-1;s>=0;s--)t.push(e[s]);t.push([t[0][0],t[0][1]]),s.push(t)}}if(s.length)return{rings:s}}t=this._inputGeometries.next()}return null}}class T{static local(){return null===T.instance&&(T.instance=new T),T.instance}execute(t,s,i){return new Y(t,s,i)}}T.instance=null;class Y extends R{constructor(t,s,i){super(t,!0,!0),this._curveHelper=new E,this._beginCut=(void 0!==s.beginCut?s.beginCut:1)*i,this._endCut=(void 0!==s.endCut?s.endCut:1)*i,this._middleCut=(void 0!==s.middleCut?s.middleCut:0)*i,this._invert=void 0!==s.invert&&s.invert,this._beginCut<0&&(this._beginCut=0),this._endCut<0&&(this._endCut=0),this._middleCut<0&&(this._middleCut=0)}processPath(t){const s=this._beginCut,i=this._endCut,e=this._middleCut,r=this._curveHelper.calculatePathLength(t),n=[];if(this._invert)if(0===s&&0===i&&0===e);else if(s+i+e>=r)n.push(t);else{let h=this._curveHelper.getSubCurve(t,0,s);h&&n.push(h),h=this._curveHelper.getSubCurve(t,.5*(r-e),.5*(r+e)),h&&n.push(h),h=this._curveHelper.getSubCurve(t,r-i,i),h&&n.push(h)}else if(0===s&&0===i&&0===e)n.push(t);else if(s+i+e>=r);else if(0===e){const e=this._curveHelper.getSubCurve(t,s,r-i);e&&n.push(e)}else{let h=this._curveHelper.getSubCurve(t,s,.5*(r-e));h&&n.push(h),h=this._curveHelper.getSubCurve(t,.5*(r+e),r-i),h&&n.push(h)}return 0===n.length?null:{paths:n}}}class B{constructor(){this._values=[],this.extPtGap=0,this.ctrlPtGap=0,this._length=0,this._currentValue=0}isEmpty(){return 0===this._values.length}size(){return this._values.length}init(t,s,i=!0){if(this._setEmpty(),!t||0===t.length)return!1;for(let s=0;s<t.length;s++){let e=Math.abs(t[s]);i&&e<1e-7&&(e=1e-7),this._values.push(e),this._length+=e}return s&&1&t.length&&(this._length*=2),0!==this._length&&(this.ctrlPtGap=this.extPtGap=0,this._currentValue=-1,!0)}scale(t){const s=this._values?this._values.length:0;for(let i=0;i<s;++i)this._values[i]*=t;this._length*=t,this.extPtGap*=t,this.ctrlPtGap*=t}addValue(t){this._length+=t,this._values.push(t)}firstValue(){return this._values[0]}lastValue(){return this._values[this._values.length-1]}nextValue(){return this._currentValue++,this._currentValue===this._values.length&&(this._currentValue=0),this._values[this._currentValue]}reset(){this._currentValue=-1}length(){return this._length}_setEmpty(){this.extPtGap=this.ctrlPtGap=this._length=0,this._currentValue=-1,this._values.length=0}}class q{constructor(){this.reset()}reset(){this.segment=-1,this.segmentLength=0,this.abscissa=0,this.isPathEnd=!1,this.isPartEnd=!1}isValid(){return-1!==this.segment}copyTo(t){t.segment=this.segment,t.segmentLength=this.segmentLength,t.abscissa=this.abscissa,t.isPathEnd=this.isPathEnd,t.isPartEnd=this.isPartEnd}}class W extends E{constructor(t=0,s=!1){super(t,s),this._tolerance=.03,this._currentPosition=new q}updateTolerance(t){this._tolerance=.03*t}init(t,s,i=!0){return i?(this._patternLength=s.length(),this._partExtPtGap=s.extPtGap,this._partCtrlPtGap=s.ctrlPtGap):(this._patternLength=0,this._partExtPtGap=0,this._partCtrlPtGap=0),this._currentPosition.reset(),this._partSegCount=0,this._path=t,this._seg=-1,this.setPosAtNextPart()}curPositionIsValid(){return this._currentPosition.isValid()}nextPosition(t,s=0){const i=new q;return!!this._nextPosition(t,i,null,s)&&(i.copyTo(this._currentPosition),!0)}curPointAndAngle(t){t.pt=this._getPoint(this._currentPosition);const[s,i]=this._getAngle(this._currentPosition);t.ca=s,t.sa=i}nextPointAndAngle(t,s,i=0){const e=new q;if(!this._nextPosition(t,e,null,i))return!1;e.copyTo(this._currentPosition),s.pt=this._getPoint(e);const[r,n]=this._getAngle(e);return s.ca=r,s.sa=n,!0}nextCurve(t){if(0===t)return null;const s=[],i=new q;return this._nextPosition(t,i,s,1)?(i.copyTo(this._currentPosition),s):null}isPathEnd(){return this._currentPosition.isPathEnd}getPathEnd(){if(-1===this._currentPosition.segment)throw new Error("missing segment");return this._path[this._currentPosition.segment+1]}_nextPosition(t,s,i,e){if(this._currentPosition.isPathEnd)return!1;let r=this._currentPosition.abscissa;for(this._currentPosition.segmentLength>0&&(r/=this._currentPosition.segmentLength),this._currentPosition.copyTo(s);s.abscissa+t*this._partLengthRatio>s.segmentLength+this._tolerance;){if(i){if(0===i.length)if(0===r){const t=this._path[s.segment];i.push([t[0],t[1]])}else i.push(this.getSegCoord2D(this._path,s.segment,r));const t=this._path[s.segment+1];i.push([t[0],t[1]])}if(r=0,t-=(s.segmentLength-s.abscissa)/this._partLengthRatio,this._partSegCount)s.segment=this.nextSegment(),s.segmentLength=this.calculateSegLength(this._path,s.segment),s.abscissa=0,this._partSegCount--;else{if(!this.setPosAtNextPart())return 0!==e&&(s.segmentLength=this.calculateSegLength(this._path,s.segment),s.isPartEnd=!0,1===e?(s.abscissa=s.segmentLength,s.isPathEnd=!0):s.abscissa=s.segmentLength+t,!0);this._currentPosition.copyTo(s)}}if(s.abscissa+=t*this._partLengthRatio,i){if(0===i.length)if(0===r){const t=this._path[s.segment];i.push([t[0],t[1]])}else i.push(this.getSegCoord2D(this._path,s.segment,r));const t=s.abscissa/s.segmentLength;if(1===t){const t=this._path[s.segment+1];i.push([t[0],t[1]])}else i.push(this.getSegCoord2D(this._path,s.segment,t))}return this._partSegCount||Math.abs(s.abscissa-s.segmentLength)<this._tolerance&&(s.isPathEnd=this._partIsLast,s.isPartEnd=!0),!0}_getPoint(t){if(-1===t.segment)throw new Error("missing segment");return this.getSegCoord2D(this._path,t.segment,t.segmentLength<=0?0:t.abscissa/t.segmentLength)}_getAngle(t){if(-1===t.segment)throw new Error("missing segment");return this.getSegAngleCS(this._path,t.segment,t.segmentLength<=0?0:t.abscissa/t.segmentLength)}setPosAtNextPart(){for(;this._partSegCount;)this.hasNextSegment()&&this.nextSegment(),this._partSegCount--;if(!this.hasNextSegment())return!1;for(this._partLength=0,this._partIsLast=!0,this._partSegCount=0;this.hasNextSegment();)if(this._partLength+=this.calculateSegLength(this._path,this.nextSegment()),this._partSegCount++,1===F(this._path[this.getEndPointIndex()])){this._partIsLast=!this.hasNextSegment();break}let t=this._partSegCount;for(;t;)this.previousSegment(),--t;this._currentPosition.segment=this.nextSegment(),this._currentPosition.segmentLength=this.calculateSegLength(this._path,this._currentPosition.segment),this._currentPosition.abscissa=0,this._currentPosition.isPathEnd=this._currentPosition.isPartEnd=!1,--this._partSegCount;const s=this.getStartPointIndex();this._ctrlPtBegin=1===F(this._path[s]);let i=s+this._partSegCount+1;if(i>=this._path.length&&(i=0),this._ctrlPtEnd=1===F(this._path[i]),this._patternLength>0){const t=this._ctrlPtBegin?this._partCtrlPtGap:this._partExtPtGap,s=this._ctrlPtEnd?this._partCtrlPtGap:this._partExtPtGap;let i=Math.round((this._partLength-(t+s))/this._patternLength);i<=0&&(i=t+s>0?0:1),this._partLengthRatio=this._partLength/(t+s+i*this._patternLength),this._partLengthRatio<.01&&(this._partLengthRatio=1)}else this._partLengthRatio=1;return!0}hasNextSegment(){return this._seg<this._path.length-2}previousSegment(){return--this._seg}nextSegment(){return++this._seg}getStartPointIndex(){return this._seg}getEndPointIndex(){return this._seg+1}}class U{static local(){return null===U.instance&&(U.instance=new U),U.instance}execute(t,s,i){return new j(t,s,i)}}U.instance=null;class j extends R{constructor(t,s,i){super(t,!0,!0),this._walker=new W,this._walker.updateTolerance(i),this._endings=s.lineDashEnding,this._customDashPos=void 0!==s.offsetAlongLine?s.offsetAlongLine*i:0,this._offsetAtEnd=void 0!==s.customEndingOffset?s.customEndingOffset*i:0,this._pattern=new B,this._pattern.init(s.dashTemplate,!0),this._pattern.scale(i)}processPath(t){if(0===this._pattern.length())return this.iteratePath=!1,{paths:[t]};if(!this.iteratePath){let s=!0;switch(this._endings){case"HalfPattern":case"HalfGap":default:this._pattern.extPtGap=0;break;case"FullPattern":this.isClosed||(this._pattern.extPtGap=.5*this._pattern.firstValue());break;case"FullGap":this.isClosed||(this._pattern.extPtGap=.5*this._pattern.lastValue());break;case"NoConstraint":this.isClosed||(s=!1);break;case"Custom":this.isClosed||(this._pattern.extPtGap=.5*this._offsetAtEnd)}const i=this._walker.calculatePathLength(t);if(this._pattern.isEmpty()||i<.1*this._pattern.length())return{paths:[t]};if(!this._walker.init(t,this._pattern,s))return{paths:[t]}}let s;if(this.iteratePath)s=this._pattern.nextValue();else{let t;switch(this._endings){case"HalfPattern":default:t=.5*this._pattern.firstValue();break;case"HalfGap":t=.5*-this._pattern.lastValue();break;case"FullGap":t=-this._pattern.lastValue();break;case"FullPattern":t=0;break;case"NoConstraint":case"Custom":t=-this._customDashPos}let i=t/this._pattern.length();i-=Math.floor(i),t=i*this._pattern.length(),this._pattern.reset(),s=this._pattern.nextValue();let e=!1;for(;t>=s;)t-=s,s=this._pattern.nextValue(),e=!e;s-=t,e?(this._walker.nextPosition(s),s=this._pattern.nextValue()):this.isClosed&&(this._firstCurve=this._walker.nextCurve(s),s=this._pattern.nextValue(),this._walker.nextPosition(s),s=this._pattern.nextValue())}let i=this._walker.nextCurve(s);return i?this._walker.isPathEnd()?(this.iteratePath=!1,this._firstCurve&&(this._firstCurve.splice(0,1),_.mergePath(i,this._firstCurve),this._firstCurve=null)):(s=this._pattern.nextValue(),!this._walker.nextPosition(s)||this._walker.isPathEnd()?(this.iteratePath=!1,this._firstCurve&&(i=this._firstCurve,this._firstCurve=null)):this.iteratePath=!0):(this.iteratePath=!1,i=this._firstCurve,this._firstCurve=null),{paths:[i]}}}class K{static local(){return null===K.instance&&(K.instance=new K),K.instance}execute(t,s,i){return new Z(t,s,i)}}K.instance=null;class Z{constructor(t,s,i){switch(this._inputGeometries=t,this._curveHelper=new E,this._width=(void 0!==s.width?s.width:2)*i,s.method){case"Mitered":default:this._method="Mitered";break;case"Bevelled":this._method="Bevelled";break;case"Rounded":case"TrueBuffer":this._method="Rounded";break;case"Square":this._method="Square"}this._option=s.option,this._offsetFlattenError=.03*i}next(){let t=this._inputGeometries.next();for(;t;){if(r(t)&&this._width>0){if(Math.min(t.xmax-t.xmin,t.ymax-t.ymin)-2*this._width<0)return t;const s=[];return s.push([[t.xmin,t.ymin],[t.xmin,t.ymax],[t.xmax,t.ymax],[t.xmax,t.ymin],[t.xmin,t.ymin]]),s.push([[t.xmin+this._width,t.ymin+this._width],[t.xmax-this._width,t.ymin+this._width],[t.xmax-this._width,t.ymax-this._width],[t.xmin+this._width,t.ymax-this._width],[t.xmin+this._width,t.ymin+this._width]]),{rings:s}}if(s(t)&&this._width>0){const s=[];for(const i of t.rings){const t=this._curveHelper.calculatePathLength(i),e=this._curveHelper.offset(i,this._width,this._method,4,this._offsetFlattenError);e&&(t<0&&e.reverse(),s.push(e))}if(s.length)return{rings:s}}t=this._inputGeometries.next()}return null}}class Q{static local(){return null===Q.instance&&(Q.instance=new Q),Q.instance}execute(t,s,i){return new tt(t,s,i)}}Q.instance=null;class tt extends R{constructor(t,s,i){super(t,!1,!0),this._curveHelper=new E,this._length=(void 0!==s.length?s.length:20)*i,this._angle=void 0!==s.angle?s.angle:225,this._position=void 0!==s.position?s.position:50,this._length<0&&(this._length=-this._length),this._position<20&&(this._position=20),this._position>80&&(this._position=80),this._mirror=!1}processPath(t){if(this._curveHelper.isEmpty(t,!1))return null;const s=t[0],i=t[t.length-1];this._curveHelper.normalize([i[0]-s[0],i[1]-s[1]]);const e=[s[0]+(i[0]-s[0])*this._position/100,s[1]+(i[1]-s[1])*this._position/100],r=Math.cos((90-this._angle)/180*Math.PI);let n=Math.sin((90-this._angle)/180*Math.PI);return this._mirror&&(n=-n),this._mirror=!this._mirror,{paths:[[s,[e[0]-this._length/2*r,e[1]-this._length/2*n],[e[0]+this._length/2*r,e[1]+this._length/2*n],i]]}}}class st{static local(){return null===st.instance&&(st.instance=new st),st.instance}execute(t,s,i){return new it(t,s,i)}}st.instance=null;class it{constructor(t,s,i){this._inputGeometries=t,this._offsetX=void 0!==s.offsetX?s.offsetX*i:0,this._offsetY=void 0!==s.offsetY?-s.offsetY*i:0}next(){let h=this._inputGeometries.next();for(;h;){if(r(h))return{xmin:h.xmin+this._offsetX,xmax:h.xmax+this._offsetX,ymin:h.ymin+this._offsetY,ymax:h.ymax+this._offsetY};if(s(h)){const s=t(h);return this._moveMultipath(s.rings,this._offsetX,this._offsetY),s}if(i(h)){const s=t(h);return this._moveMultipath(s.paths,this._offsetX,this._offsetY),s}if(e(h)){const s=t(h);return this._movePath(s.points,this._offsetX,this._offsetY),s}if(n(h))return{x:h.x+this._offsetX,y:h.y+this._offsetY};h=this._inputGeometries.next()}return null}_moveMultipath(t,s,i){if(t)for(const e of t)this._movePath(e,s,i)}_movePath(t,s,i){if(t)for(const e of t)e[0]+=s,e[1]+=i}}class et{static local(){return null===et.instance&&(et.instance=new et),et.instance}execute(t,s,i){return new rt(t,s,i)}}et.instance=null;class rt{constructor(t,s,i){this._inputGeometries=t,this._curveHelper=new E,this._offset=(void 0!==s.offset?s.offset:1)*i,this._method=s.method,this._option=s.option,this._offsetFlattenError=.03*i}next(){let t=this._inputGeometries.next();for(;t;){if(0===this._offset)return t;if(r(t)){if("Rounded"===this._method&&this._offset>0){const s=this._curveHelper.offset([[t.xmin,t.ymin],[t.xmin,t.ymax],[t.xmax,t.ymax],[t.xmax,t.ymin],[t.xmin,t.ymin]],this._offset,this._method,4,this._offsetFlattenError);return s?{rings:[s]}:null}if(Math.min(t.xmax-t.xmin,t.ymax-t.ymin)+2*this._offset>0)return{xmin:t.xmin-this._offset,xmax:t.xmax+this._offset,ymin:t.ymin-this._offset,ymax:t.ymax+this._offset}}if(s(t)){const s=[];for(const i of t.rings){const t=this._curveHelper.offset(i,this._offset,this._method,4,this._offsetFlattenError);t&&s.push(t)}if(s.length)return{rings:s}}if(i(t)){const s=[];for(const i of t.paths){const t=this._curveHelper.offset(i,this._offset,this._method,4,this._offsetFlattenError);t&&s.push(t)}if(s.length)return{paths:s}}t=this._inputGeometries.next()}return null}}class nt{static local(){return null===nt.instance&&(nt.instance=new nt),nt.instance}execute(t,s,i){return new ht(t,s,i)}}nt.instance=null;class ht{constructor(t,s,i){this._inputGeometries=t,this._reverse=void 0===s.reverse||s.reverse}next(){let s=this._inputGeometries.next();for(;s;){if(!this._reverse)return s;if(i(s)){const i=t(s);return P(i.paths),i}s=this._inputGeometries.next()}return null}}class ot{static local(){return null===ot.instance&&(ot.instance=new ot),ot.instance}execute(t,s,i){return new at(t,s,i)}}ot.instance=null;class at{constructor(t,s,i){this._inputGeometries=t,this._rotateAngle=void 0!==s.angle?-s.angle*Math.PI/180:0}next(){let o=this._inputGeometries.next();for(;o;){if(0===this._rotateAngle)return o;const a=C();h(a,o);const c=(a[2]+a[0])/2,l=(a[3]+a[1])/2;if(r(o)){const t={rings:[[[o.xmin,o.ymin],[o.xmin,o.ymax],[o.xmax,o.ymax],[o.xmax,o.ymin],[o.xmin,o.ymin]]]};return this._rotateMultipath(t.rings,c,l),t}if(s(o)){const s=t(o);return this._rotateMultipath(s.rings,c,l),s}if(i(o)){const s=t(o);return this._rotateMultipath(s.paths,c,l),s}if(e(o)){const s=t(o);return this._rotatePath(s.points,c,l),s}if(n(o))return o;o=this._inputGeometries.next()}return null}_rotateMultipath(t,s,i){if(t)for(const e of t)this._rotatePath(e,s,i)}_rotatePath(t,s,i){if(t){const e=Math.cos(this._rotateAngle),r=Math.sin(this._rotateAngle);for(const n of t){const t=n[0]-s,h=n[1]-i;n[0]=s+t*e-h*r,n[1]=i+t*r+h*e}}}}class ct{static local(){return null===ct.instance&&(ct.instance=new ct),ct.instance}execute(t,s,i){return new lt(t,s,i)}}ct.instance=null;class lt{constructor(t,s,i){this._inputGeometries=t,this._xFactor=void 0!==s.xScaleFactor?s.xScaleFactor:1.15,this._yFactor=void 0!==s.yScaleFactor?s.yScaleFactor:1.15}next(){let o=this._inputGeometries.next();for(;o;){if(1===this._xFactor&&1===this._yFactor)return o;const a=C();h(a,o);const c=(a[2]+a[0])/2,l=(a[3]+a[1])/2;if(r(o)){const t={rings:[[[o.xmin,o.ymin],[o.xmin,o.ymax],[o.xmax,o.ymax],[o.xmax,o.ymin],[o.xmin,o.ymin]]]};return this._scaleMultipath(t.rings,c,l),t}if(s(o)){const s=t(o);return this._scaleMultipath(s.rings,c,l),s}if(i(o)){const s=t(o);return this._scaleMultipath(s.paths,c,l),s}if(e(o)){const s=t(o);return this._scalePath(s.points,c,l),s}if(n(o))return o;o=this._inputGeometries.next()}return null}_scaleMultipath(t,s,i){if(t)for(const e of t)this._scalePath(e,s,i)}_scalePath(t,s,i){if(t)for(const e of t){const t=(e[1]-i)*this._yFactor;e[0]=s+(e[0]-s)*this._xFactor,e[1]=i+t}}}class ut{static local(){return null===ut.instance&&(ut.instance=new ut),ut.instance}execute(t,s,i){return new ft(t,s,i)}}ut.instance=null;class ft{constructor(t,s,i){this._inputGeometries=t,this._height=(void 0!==s.amplitude?s.amplitude:2)*i,this._period=(void 0!==s.period?s.period:3)*i,this._style=s.waveform,this._height<=0&&(this._height=Math.abs(this._height)),this._period<=0&&(this._period=Math.abs(this._period)),this._pattern=new B,this._pattern.addValue(this._period),this._pattern.addValue(this._period),this._walker=new W,this._walker.updateTolerance(i)}next(){let t=this._inputGeometries.next();for(;t;){if(0===this._height||0===this._period)return t;if(i(t)){const s=this._processGeom(t.paths);if(s.length)return{paths:s}}if(s(t)){const s=this._processGeom(t.rings);if(s.length)return{rings:s}}t=this._inputGeometries.next()}return null}_processGeom(t){const s=[];for(const i of t)if(this._walker.init(i,this._pattern))switch(this._style){case"Sinus":default:s.push(this._constructCurve(i,!1));break;case"Square":s.push(this._constructSquare(i));break;case"Triangle":s.push(this._constructTriangle(i));break;case"Random":s.push(this._constructCurve(i,!0))}else s.push(i);return s}_constructCurve(t,s){const i=new _,e=this._walker.calculatePathLength(t);let r=Math.round(e/this._period);0===r&&(r=1);const n=this._period/16,h=1/(16*r+1),o=2*Math.PI*e/(e/r),a=2*Math.PI*Math.random(),c=2*Math.PI*Math.random(),l=2*Math.PI*Math.random(),u=.75-Math.random()/2,f=.75-Math.random()/2,d={};this._walker.curPointAndAngle(d),i.startPath(d.pt);let M=0;for(;;){if(!this._walker.nextPointAndAngle(n,d)){i.lineTo(t[t.length-1]);break}{const t=M;let e;if(M+=h,s){const s=this._height/2*(1+.3*Math.sin(u*o*t+a));e=s*Math.sin(o*t+c),e+=s*Math.sin(f*o*t+l),e/=2}else e=.5*this._height*Math.sin(.5*o*t);i.lineTo([d.pt[0]-e*d.sa,d.pt[1]+e*d.ca])}}return i.path()}_constructSquare(t){const s=new _;this._walker.calculatePathLength(t);let i=!0;for(;;){let t=!1;if(this._walker.curPositionIsValid()){const e={};this._walker.curPointAndAngle(e);const r={};if(this._walker.nextPointAndAngle(this._period,r)){const n={};this._walker.nextPointAndAngle(this._period,n)&&(i?(s.startPath(e.pt),i=!1):s.lineTo(e.pt),s.lineTo([e.pt[0]-this._height/2*e.sa,e.pt[1]+this._height/2*e.ca]),s.lineTo([r.pt[0]-this._height/2*r.sa,r.pt[1]+this._height/2*r.ca]),s.lineTo([r.pt[0]+this._height/2*r.sa,r.pt[1]-this._height/2*r.ca]),s.lineTo([n.pt[0]+this._height/2*n.sa,n.pt[1]-this._height/2*n.ca]),t=!0)}}if(!t){s.lineTo(this._walker.getPathEnd());break}}return s.path()}_constructTriangle(t){const s=new _;this._walker.calculatePathLength(t);let i=!0;for(;;){let t=!1;if(this._walker.curPositionIsValid()){const e={};this._walker.curPointAndAngle(e);const r={};if(this._walker.nextPointAndAngle(this._period/2,r)){const n={};this._walker.nextPointAndAngle(this._period,n)&&(this._walker.nextPosition(this._period/2)&&(i?(s.startPath(e.pt),i=!1):s.lineTo(e.pt),s.lineTo([r.pt[0]-this._height/2*r.sa,r.pt[1]+this._height/2*r.ca]),s.lineTo([n.pt[0]+this._height/2*n.sa,n.pt[1]-this._height/2*n.ca])),t=!0)}}if(!t){s.lineTo(this._walker.getPathEnd());break}}return s.path()}}var dt;!function(t){t.NoConstraint="NoConstraint",t.WithMarkers="WithMarkers",t.WithFullGap="WithFullGap",t.WithHalfGap="WithHalfGap",t.Custom="Custom"}(dt||(dt={}));class Mt{static local(){return null===Mt.instance&&(Mt.instance=new Mt),Mt.instance}execute(t,s,i){return new mt(t,s,i)}}Mt.instance=null;class mt extends N{constructor(t,s,i){super(t,!0,!0),this._grometryWalker=new W,this._grometryWalker.updateTolerance(i),this._angleToLine=void 0===s.angleToLine||s.angleToLine,this._offset=void 0!==s.offset?s.offset*i:0,this._originalEndings=s.endings,this._offsetAtEnd=void 0!==s.customEndingOffset?s.customEndingOffset*i:0,this._position=void 0!==s.offsetAlongLine?s.offsetAlongLine*i:0,this._pattern=new B,this._pattern.init(s.placementTemplate,!1),this._pattern.scale(i),this._endings=this._originalEndings}processPath(t){if(this._pattern.isEmpty())return null;let s;if(this.iteratePath)s=this._pattern.nextValue();else{this._endings=this._originalEndings===dt.WithFullGap&&this.isClosed?dt.WithMarkers:this._originalEndings,this._pattern.extPtGap=0;let i,e=!0;switch(this._endings){case dt.NoConstraint:i=-this._position,i=this._adjustPosition(i),e=!1;break;case dt.WithHalfGap:default:i=-this._pattern.lastValue()/2;break;case dt.WithFullGap:i=-this._pattern.lastValue(),this._pattern.extPtGap=this._pattern.lastValue();break;case dt.WithMarkers:i=0;break;case dt.Custom:i=-this._position,i=this._adjustPosition(i),this._pattern.extPtGap=.5*this._offsetAtEnd}if(!this._grometryWalker.init(t,this._pattern,e))return null;this._pattern.reset();let r=0;for(;i>r;)i-=r,r=this._pattern.nextValue();r-=i,s=r,this.iteratePath=!0}const i={};return this._grometryWalker.nextPointAndAngle(s,i)?this._endings===dt.WithFullGap&&this._grometryWalker.isPathEnd()?(this.iteratePath=!1,null):this._endings===dt.WithMarkers&&this._grometryWalker.isPathEnd()&&(this.iteratePath=!1,this.isClosed)?null:(this.internalPlacement.setTranslate(i.pt[0]+this._offset*i.sa,i.pt[1]-this._offset*i.ca),this._angleToLine&&this.internalPlacement.setRotateCS(i.ca,i.sa),this.internalPlacement):(this.iteratePath=!1,null)}_adjustPosition(t){let s=t/this._pattern.length();return s-=Math.floor(s),s*this._pattern.length()}}class St{static local(){return null===St.instance&&(St.instance=new St),St.instance}execute(t,s,i){return new yt(t,s,i)}}St.instance=null;class yt extends N{constructor(t,s,i){super(t,!1,!0),this._curveHelper=new E,this._angleToLine=void 0===s.angleToLine||s.angleToLine,this._offset=void 0!==s.offset?s.offset*i:0,this._type=s.extremityPlacement,this._position=void 0!==s.offsetAlongLine?s.offsetAlongLine*i:0,this._beginProcessed=!1}processPath(t){let s;switch(this._type){case"Both":default:this._beginProcessed?(s=this._atExtremities(t,this._position,!1),this._beginProcessed=!1,this.iteratePath=!1):(s=this._atExtremities(t,this._position,!0),this._beginProcessed=!0,this.iteratePath=!0);break;case"JustBegin":s=this._atExtremities(t,this._position,!0);break;case"JustEnd":s=this._atExtremities(t,this._position,!1);break;case"None":}return s}_atExtremities(t,s,i){const e=t.length;if(e<2)return null;const r=i?e:-1,n=i?1:-1;let h,o=0,a=i?t[0]:t[e-1];for(let i=i?1:e-2;i!==r;i+=n){h=a,a=t[i];const e=this._curveHelper.calculateLength(h,a);if(o+e>s){const t=(s-o)/e,[i,r]=this._curveHelper.getAngleCS(h,a,t),n=L(h,a,t);return this.internalPlacement.setTranslate(n[0]-this._offset*r,n[1]+this._offset*i),this._angleToLine&&this.internalPlacement.setRotateCS(-i,-r),this.internalPlacement}o+=e}return null}}class Ct{static local(){return null===Ct.instance&&(Ct.instance=new Ct),Ct.instance}execute(t,s,i){return new bt(t,s,i)}}Ct.instance=null;class bt extends N{constructor(t,s,i){super(t,!0,!0),this._walker=new W,this._walker.updateTolerance(i),this._angleToLine=void 0===s.angleToLine||s.angleToLine,this._offset=void 0!==s.offset?s.offset*i:0,this._beginGap=void 0!==s.beginPosition?s.beginPosition*i:0,this._endGap=void 0!==s.endPosition?s.endPosition*i:0,this._flipFirst=void 0===s.flipFirst||s.flipFirst,this._pattern=new B,this._pattern.init(s.positionArray,!1,!1),this._subPathLen=0,this._posCount=this._pattern.size(),this._isFirst=!0,this._prevPos=0}processPath(t){if(this._pattern.isEmpty())return null;let s;if(this.iteratePath){const t=this._pattern.nextValue()*this._subPathLen,i=this._beginGap+t;s=i-this._prevPos,this._prevPos=i}else{if(this._posCount=this._pattern.size(),this._isFirst=!0,this._prevPos=0,this._subPathLen=this._walker.calculatePathLength(t)-this._beginGap-this._endGap,this._subPathLen<0)return this.iteratePath=!1,null;if(!this._walker.init(t,this._pattern,!1))return null;this._pattern.reset();const i=this._pattern.nextValue()*this._subPathLen,e=this._beginGap+i;s=e-this._prevPos,this._prevPos=e,this.iteratePath=!0}const i={};if(!this._walker.nextPointAndAngle(s,i,1))return this.iteratePath=!1,null;let e,r;return this.internalPlacement.setTranslate(i.pt[0]+this._offset*i.sa,i.pt[1]-this._offset*i.ca),this._angleToLine?(e=i.ca,r=i.sa):(e=1,r=0),this._isFirst&&this._flipFirst&&(e=-e,r=-r),this.internalPlacement.setRotateCS(e,r),this._isFirst=!1,this._posCount--,0===this._posCount&&(this.iteratePath=!1),this.internalPlacement}}class kt{static local(){return null===kt.instance&&(kt.instance=new kt),kt.instance}execute(t,s,i){return new pt(t,s,i)}}kt.instance=null;class pt{constructor(t,s,i){if(this._xMin=0,this._xMax=0,this._yMin=0,this._yMax=0,this._currentX=0,this._currentY=0,this._stepX=(void 0!==s.stepX?Math.abs(s.stepX):16)*i,this._stepY=(void 0!==s.stepY?Math.abs(s.stepY):16)*i,0!==this._stepX&&0!==this._stepY&&t&&void 0!==t.rings&&t.rings){if(this._gridType=void 0!==s.gridType?s.gridType:"Fixed","Random"===this._gridType)this._randomness=void 0!==s.randomness?s.randomness/100:1,this._gridAngle=0,this._shiftOddRows=!1,this._cosAngle=1,this._sinAngle=0,this._offsetX=0,this._offsetY=0;else{if(this._randomness=0,this._gridAngle=void 0!==s.gridAngle?s.gridAngle:0,this._shiftOddRows=void 0!==s.shiftOddRows&&s.shiftOddRows,this._offsetX=void 0!==s.offsetX?s.offsetX*i:0,this._offsetY=void 0!==s.offsetY?s.offsetY*i:0,this._cosAngle=Math.cos(this._gridAngle/180*Math.PI),this._sinAngle=-Math.sin(this._gridAngle/180*Math.PI),this._stepX)if(this._offsetX<0)for(;this._offsetX<-.5*this._stepX;)this._offsetX+=this._stepX;else for(;this._offsetX>=.5*this._stepX;)this._offsetX-=this._stepX;if(this._stepY)if(this._offsetY<0)for(;this._offsetY<-.5*this._stepY;)this._offsetY+=this._stepY;else for(;this._offsetY>=.5*this._stepY;)this._offsetY-=this._stepY}this._graphicOriginX=0,this._graphicOriginY=0,this._internalPlacement=new b,this._calculateMinMax(t),this._geometry=t}}next(){return this._geometry?this._nextInside():null}_calculateMinMax(t){let s,i,e,r,n,h,o,a;this._xMin=0,this._xMax=0,this._yMin=0,this._yMax=0,n=h=Number.MAX_VALUE,o=a=-Number.MAX_VALUE;for(const c of t.rings){const t=c?c.length:0;for(let l=0;l<t;++l)s=c[l][0]-this._graphicOriginX-this._offsetX,i=c[l][1]-this._graphicOriginY-this._offsetY,e=this._cosAngle*s-this._sinAngle*i,r=this._sinAngle*s+this._cosAngle*i,n=Math.min(n,e),o=Math.max(o,e),h=Math.min(h,r),a=Math.max(a,r)}n+=this._graphicOriginX,o+=this._graphicOriginX,h+=this._graphicOriginY,a+=this._graphicOriginY,this._xMin=Math.round(n/this._stepX),this._xMax=Math.round(o/this._stepX),this._yMin=Math.round(h/this._stepY),this._yMax=Math.round(a/this._stepY),this._currentX=this._xMax+1,this._currentY=this._yMin-1}_nextInside(){for(;;){if(this._currentX>this._xMax){if(this._currentY++,this._currentY>this._yMax)return null;this._currentX=this._xMin,this._shiftOddRows&&this._currentY%2&&this._currentX--}let t=this._currentX*this._stepX+this._offsetX;this._shiftOddRows&&this._currentY%2&&(t+=.5*this._stepX);const s=this._currentY*this._stepY+this._offsetY;let i,e;return this._currentX++,"Random"===this._gridType?(i=this._graphicOriginX+t+this._stepX*this._randomness*(.5-Math.random())*2/3,e=this._graphicOriginY+s+this._stepY*this._randomness*(.5-Math.random())*2/3):(i=this._graphicOriginX+this._cosAngle*t+this._sinAngle*s,e=this._graphicOriginY-this._sinAngle*t+this._cosAngle*s),this._internalPlacement.setTranslate(i,e),this._internalPlacement}}}class gt{static local(){return null===gt.instance&&(gt.instance=new gt),gt.instance}execute(t,s,i){return new wt(t,s,i)}}gt.instance=null;class wt extends N{constructor(t,s,i){super(t,!0,!0),this._curveHelper=new E,this._angleToLine=void 0===s.angleToLine||s.angleToLine,this._offset=void 0!==s.offset?s.offset*i:0,this._relativeTo=s.relativeTo,this._position=void 0!==s.startPointOffset?s.startPointOffset*i:0,this._epsilon=.001*i}processPath(t){const s=this._position;if("SegmentMidpoint"===this._relativeTo){for(this.iteratePath||(this._segmentCount=t.length,this._curSegment=1,this.iteratePath=!0);this._curSegment<this._segmentCount;){const s=this._curSegment;this._curSegment++;const i=t[s-1],e=t[s],r=this._curveHelper.calculateLength(i,e);if(r<this._epsilon)continue;const n=.5+this._position/r,[h,o]=this._curveHelper.getAngleCS(i,e,n),a=L(i,e,n);return this.internalPlacement.setTranslate(a[0]-this._offset*o,a[1]+this._offset*h),this._angleToLine&&this.internalPlacement.setRotateCS(h,o),this.internalPlacement}return this.iteratePath=!1,null}"LineEnd"===this._relativeTo&&O(t);const i=this.onLine(t,s);return"LineEnd"===this._relativeTo&&O(t),i}onLine(t,s){let i,e=!1;switch(this._relativeTo){case"LineMiddle":default:i=this._curveHelper.calculatePathLength(t)/2+s;break;case"LineBeginning":i=s;break;case"LineEnd":i=s,e=!0}const r=t.length;let n,h=0,o=t[0];for(let s=1;s<r;++s){n=o,o=t[s];const r=this._curveHelper.calculateLength(n,o);if(h+r>i){const t=(i-h)/r,[s,a]=this._curveHelper.getAngleCS(n,o,t),c=L(n,o,t),l=e?this._offset:-this._offset;return this.internalPlacement.setTranslate(c[0]-l*a,c[1]+l*s),this._angleToLine&&(e?this.internalPlacement.setRotateCS(-s,-a):this.internalPlacement.setRotateCS(s,a)),this.internalPlacement}h+=r}return null}}class It{static local(){return null===It.instance&&(It.instance=new It),It.instance}execute(t,s,i){return new xt(t,s,i)}}It.instance=null;class xt extends N{constructor(t,s,i){super(t,!0,!0),this._curveHelper=new E,this._angleToLine=void 0===s.angleToLine||s.angleToLine,this._offset=void 0!==s.offset?s.offset*i:0,this._endPoints=void 0===s.placeOnEndPoints||s.placeOnEndPoints,this._controlPoints=void 0===s.placeOnControlPoints||s.placeOnControlPoints,this._regularVertices=void 0===s.placeOnRegularVertices||s.placeOnRegularVertices,this._tags=[],this._tagIterator=0}processPath(t){if(this.iteratePath||(this._preparePath(t),this.iteratePath=!0),this._tagIterator>=this._tags.length)return this._tags.length=0,this._tagIterator=0,this.iteratePath=!1,null;const s=this._tags[this._tagIterator];this._angleToLine&&this.internalPlacement.setRotate(s[2]);let i=s[0],e=s[1];if(0!==this._offset){const t=Math.cos(s[2]),r=Math.sin(s[2]);i-=this._offset*r,e+=this._offset*t}return this.internalPlacement.setTranslate(i,e),this._tagIterator++,this.internalPlacement}_preparePath(t){this._tags.length=0,this._tagIterator=0;const s=function(t){return!(!t||0===t.length)&&t[0][0]===t[t.length-1][0]&&t[0][1]===t[t.length-1][1]}(t),i=t.length-1;let e,r,n=0,h=0,o=0,a=0,c=0;for(;n<i;){n++,e=t[n-1],r=t[n];const l=F(e),u=F(r);(this._angleToLine||0!==this._offset)&&(a=this._curveHelper.getAngle(e,r,0)),1===n?s?(h=a,o=l):this._endPoints&&this._tags.push([e[0],e[1],a]):1===l?this._controlPoints&&this._tags.push([e[0],e[1],vt(c,a)]):this._regularVertices&&this._tags.push([e[0],e[1],vt(c,a)]),(this._angleToLine||0!==this._offset)&&(c=this._curveHelper.getAngle(e,r,1)),n===i&&(s?1===u||1===o?this._controlPoints&&this._tags.push([r[0],r[1],vt(c,h)]):this._regularVertices&&this._tags.push([r[0],r[1],vt(c,h)]):this._endPoints&&this._tags.push([r[0],r[1],c]))}this._tagIterator=0}}function vt(t,s){const i=Math.PI;for(;Math.abs(s-t)>i+2e-15;)s-t>i?s-=2*i:s+=2*i;return(t+s)/2}class Pt{static local(){return null===Pt.instance&&(Pt.instance=new Pt),Pt.instance}execute(t,s,i){return new Ot(t,s,i)}}Pt.instance=null;class Ot{constructor(t,s,i){this._geometry=t,this._offsetX=void 0!==s.offsetX?s.offsetX*i:0,this._offsetY=void 0!==s.offsetY?s.offsetY*i:0,this._method=void 0!==s.method?s.method:"OnPolygon",this._internalPlacement=new b}next(){const t=this._geometry;return this._geometry=null,t&&void 0!==t.rings?this._polygonCenter(t):null}_polygonCenter(t){let s=!1;switch(this._method){case"OnPolygon":default:case"CenterOfMass":case"BoundingBoxCenter":{const i=C();h(i,t),this._internalPlacement.setTranslate((i[2]+i[0])/2+this._offsetX,(i[3]+i[1])/2-this._offsetY),s=!0;break}}return s?this._internalPlacement:null}}function Lt(t){if(!t)return null;switch(t.type){case"CIMGeometricEffectAddControlPoints":return H.local();case"CIMGeometricEffectArrow":return D.local();case"CIMGeometricEffectBuffer":return V.local();case"CIMGeometricEffectCut":return T.local();case"CIMGeometricEffectDashes":return U.local();case"CIMGeometricEffectDonut":return K.local();case"CIMGeometricEffectJog":return Q.local();case"CIMGeometricEffectMove":return st.local();case"CIMGeometricEffectOffset":return et.local();case"CIMGeometricEffectReverse":return nt.local();case"CIMGeometricEffectRotate":return ot.local();case"CIMGeometricEffectScale":return ct.local();case"CIMGeometricEffectWave":return ut.local()}return null}function Ft(t){if(!t)return null;switch(t.type){case"CIMMarkerPlacementAlongLineSameSize":return Mt.local();case"CIMMarkerPlacementAtExtremities":return St.local();case"CIMMarkerPlacementAtRatioPositions":return Ct.local();case"CIMMarkerPlacementInsidePolygon":return kt.local();case"CIMMarkerPlacementOnLine":return gt.local();case"CIMMarkerPlacementOnVertices":return It.local();case"CIMMarkerPlacementPolygonCenter":return Pt.local()}return null}class At{constructor(t=0,s=0,i=0,e=0){this.x=t,this.y=s,this.width=i,this.height=e}get isEmpty(){return this.width<=0||this.height<=0}union(t){this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.width=Math.max(this.width,t.width),this.height=Math.max(this.height,t.height)}}const Nt=Math.PI/180,Rt=o.getLogger("esri.symbols.cim.CIMSymbolDrawHelper");class zt{constructor(t){this._t=t}static createIdentity(){return new zt([1,0,0,0,1,0])}clone(){return new zt(this._t.slice())}transform(t){const s=this._t;return[s[0]*t[0]+s[1]*t[1]+s[2],s[3]*t[0]+s[4]*t[1]+s[5]]}static createScale(t,s){return new zt([t,0,0,0,s,0])}scale(t,s){const i=this._t;return i[0]*=t,i[1]*=t,i[2]*=t,i[3]*=s,i[4]*=s,i[5]*=s,this}scaleRatio(){return Math.sqrt(this._t[0]*this._t[0]+this._t[1]*this._t[1])}static createTranslate(t,s){return new zt([0,0,t,0,0,s])}translate(t,s){const i=this._t;return i[2]+=t,i[5]+=s,this}static createRotate(t){const s=Math.cos(t),i=Math.sin(t);return new zt([s,-i,0,i,s,0])}rotate(t){return this.multiply(zt.createRotate(t))}multiply(t){const s=this._t,i=t._t,e=s[1]*i[0]+s[4]*i[1],r=s[2]*i[0]+s[5]*i[1]+i[2],n=s[0]*i[3]+s[3]*i[4],h=s[1]*i[3]+s[4]*i[4],o=s[2]*i[3]+s[5]*i[4]+i[5];return s[0]=s[0]*i[0]+s[3]*i[1],s[1]=e,s[2]=r,s[3]=n,s[4]=h,s[5]=o,this}}class Ht{constructor(t){this._transfos=[],this._sizeTransfos=[],this._transfos.push(t||zt.createIdentity()),this._sizeTransfos.push(t?t.scaleRatio():1)}transformPt(t){return this._transfos[this._transfos.length-1].transform(t)}transformSize(t){return t*this._sizeTransfos[this._sizeTransfos.length-1]}back(){return this._transfos[this._transfos.length-1]}push(t,s){const i=s?t.scaleRatio():1;t.multiply(this.back()),this._transfos.push(t),this._sizeTransfos.push(this._sizeTransfos[this._sizeTransfos.length-1]*i)}pop(){this._transfos.splice(-1,1),this._sizeTransfos.splice(-1,1)}drawSymbol(t,s){if(t)switch(t.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":this.drawMultiLayerSymbol(t,s)}}drawMultiLayerSymbol(t,s){if(!t)return;const i=t.symbolLayers;if(!i)return;const e=t.effects;if(e){const t=this.executeEffects(e,s);if(t){let s=t.next();for(;s;)this.drawSymbolLayers(i,s),s=t.next()}}else this.drawSymbolLayers(i,s)}executeEffects(t,s){let i=new k(s);for(const s of t){const t=Lt(s);t&&(i=t.execute(i,s,1))}return i}drawSymbolLayers(t,s){let i=t.length;for(;i--;){const e=t[i];if(!e||!1===e.enable)continue;const r=e.effects;if(r){const t=this.executeEffects(r,s);if(t){let s=t.next();for(;s;)this.drawSymbolLayer(e,s),s=t.next()}}else this.drawSymbolLayer(e,s)}}drawSymbolLayer(t,s){switch(t.type){case"CIMSolidFill":this.drawSolidFill(s,t.color);break;case"CIMHatchFill":this.drawHatchFill(t,s);break;case"CIMSolidStroke":this.drawSolidStroke(s,t.color,t.width,t.capStyle,t.joinStyle,t.miterLimit);break;case"CIMCharacterMarker":case"CIMPictureMarker":case"CIMVectorMarker":this.drawMarkerLayer(t,s)}}drawHatchFill(t,s){const i=this._buildHatchPolyline(t,s,1);i&&(this.pushClipPath(s),this.drawMultiLayerSymbol(t.lineSymbol,i),this.popClipPath())}drawMarkerLayer(t,s){const i=t.markerPlacement;if(i){const e=Ft(i);if(e){const r="CIMMarkerPlacementInsidePolygon"===i.type;r&&this.pushClipPath(s);const n=e.execute(s,i,1);if(n){let s=n.next();for(;s;)this.drawMarker(t,s),s=n.next()}r&&this.popClipPath()}}else{const i=new b;i.tx=s.x,i.ty=s.y,this.drawMarker(t,i)}}drawMarker(t,s){switch(t.type){case"CIMCharacterMarker":case"CIMPictureMarker":this.drawPictureMarker(t,s);break;case"CIMVectorMarker":this.drawVectorMarker(t,s)}}drawPictureMarker(t,s){}drawVectorMarker(t,s){if(!t)return;const i=t.markerGraphics;if(!i)return;const e=t.size,r=t.frame,n=r?r.ymax-r.ymin:0,h=e&&n?e/n:1,o=zt.createIdentity();r&&o.translate(.5*-(r.xmax+r.xmin),.5*-(r.ymax+r.ymin));const a=t.anchorPoint;if(a){let s=a.x,i=a.y;"Absolute"!==t.anchorPointUnits&&r&&(s*=r.xmax-r.xmin,i*=r.ymax-r.ymin),o.translate(-s,-i)}1!==h&&o.scale(h,h),t.rotation&&o.rotate(t.rotation*Nt),o.translate(t.offsetX||0,t.offsetY||0),o.translate(s.tx,s.ty),this.push(o,t.scaleSymbolsProportionally);for(const t of i)t&&t.symbol&&t.geometry||Rt.error("Invalid marker graphic",t),this.drawSymbol(t.symbol,t.geometry);this.pop()}_buildHatchPolyline(t,s,i){let e=(void 0!==t.separation?t.separation:4)*i,r=void 0!==t.rotation?t.rotation:0;if(0===e)return null;e<0&&(e=-e);let n=0;const o=.5*e;for(;n>o;)n-=e;for(;n<-o;)n+=e;const a=C();h(a,s),a[0]-=o,a[1]-=o,a[2]+=o,a[3]+=o;const c=[[a[0],a[1]],[a[0],a[3]],[a[2],a[3]],[a[2],a[1]]];for(;r>180;)r-=180;for(;r<0;)r+=180;const l=Math.cos(r*Nt),u=Math.sin(r*Nt),f=-e*u,d=e*l;let M,m,S,y;n=(void 0!==t.offsetX?t.offsetX*i:0)*u-(void 0!==t.offsetY?t.offsetY*i:0)*l,M=S=Number.MAX_VALUE,m=y=-Number.MAX_VALUE;for(const t of c){const s=t[0],i=t[1],e=l*s+u*i,r=-u*s+l*i;M=Math.min(M,e),S=Math.min(S,r),m=Math.max(m,e),y=Math.max(y,r)}S=Math.floor(S/e)*e;let b=l*M-u*S-f*n/e,k=u*M+l*S-d*n/e,p=l*m-u*S-f*n/e,g=u*m+l*S-d*n/e;const w=1+Math.round((y-S)/e),I=[];for(let t=0;t<w;t++)b+=f,k+=d,p+=f,g+=d,I.push([[b,k],[p,g]]);return{paths:I}}}class Jt extends Ht{constructor(){super(),this.reset()}reset(){this._xmin=this._ymin=1/0,this._xmax=this._ymax=-1/0,this._clipCount=0}envelope(){return new At(this._xmin,this._ymin,this._xmax-this._xmin,this._ymax-this._ymin)}drawSolidFill(t){!t||this._clipCount>0||(s(t)?this._processPath(t.rings,0):i(t)&&this._processPath(t.paths,0))}drawSolidStroke(t,e,r){if(!t||this._clipCount>0)return;const n=.5*this.transformSize(r);s(t)?this._processPath(t.rings,n):i(t)&&this._processPath(t.paths,n)}pushClipPath(t){this.drawSolidFill(t),++this._clipCount}popClipPath(){--this._clipCount}_processPath(t,s){if(t)for(const i of t){const t=i?i.length:0;if(t>1){this._merge(this.transformPt(i[0]),s);for(let e=1;e<t;++e)this._merge(this.transformPt(i[e]),s)}}}_merge(t,s){t[0]-s<this._xmin&&(this._xmin=t[0]-s),t[0]+s>this._xmax&&(this._xmax=t[0]+s),t[1]-s<this._ymin&&(this._ymin=t[1]-s),t[1]+s>this._ymax&&(this._ymax=t[1]+s)}}class _t extends Ht{constructor(t,s){super(s),this._ctx=t}drawSolidFill(t,e){if(!t)return;if(s(t))this._buildPath(t.rings,!0);else{if(!i(t))return;this._buildPath(t.paths,!0)}const r=this._ctx;r.fillStyle="string"==typeof e?e:"rgba("+Math.round(e[0])+","+Math.round(e[1])+","+Math.round(e[2])+","+e[3]/255+")",r.fill("evenodd")}drawSolidStroke(t,e,r,n,h,o){if(!t||!e||0===r)return;if(s(t))this._buildPath(t.rings,!0);else{if(!i(t))return;this._buildPath(t.paths,!1)}const a=this._ctx;a.strokeStyle="string"==typeof e?e:"rgba("+Math.round(e[0])+","+Math.round(e[1])+","+Math.round(e[2])+","+e[3]/255+")",a.lineWidth=this.transformSize(r)+.5,this._setCapStyle(n),this._setJoinStyle(h),a.miterLimit=o,a.stroke()}pushClipPath(t){this._ctx.save(),s(t)?this._buildPath(t.rings,!0):i(t)&&this._buildPath(t.paths,!0),this._ctx.clip("evenodd")}popClipPath(){this._ctx.restore()}_buildPath(t,s){const i=this._ctx;if(i.beginPath(),t)for(const e of t){const t=e?e.length:0;if(t>1){let r=this.transformPt(e[0]);i.moveTo(r[0],r[1]);for(let s=1;s<t;++s)r=this.transformPt(e[s]),i.lineTo(r[0],r[1]);s&&i.closePath()}}}_setCapStyle(t){switch(t){case"Butt":this._ctx.lineCap="butt";break;case"Round":this._ctx.lineCap="round";break;case"Square":this._ctx.lineCap="square"}}_setJoinStyle(t){switch(t){case"Bevel":this._ctx.lineJoin="bevel";break;case"Round":this._ctx.lineJoin="round";break;case"Miter":this._ctx.lineJoin="miter"}}}const Et=[1,256,65536,16777216],Gt=[1/256,1/65536,1/16777216,1/4294967296],Dt=function(t,s=0){let i=0;for(let e=0;e<4;e++)i+=t[s+e]*Gt[e];return i}(new Uint8ClampedArray([255,255,255,255]));function Xt(t,s,i=0){const e=function(t){return t<0?0:t>Dt?Dt:t}(t);for(let t=0;t<4;t++)s[i+t]=Math.floor(256*((r=e*Et[t])-Math.floor(r)));var r}const Vt=Math.PI,$t=Vt/2,Tt=o.getLogger("esri.symbols.cim.CIMSymbolHelper");function Yt(t,s){switch(s.type){case"CIMSymbolReference":t.drawSymbol(s.symbol,{type:"point",x:0,y:0});break;case"CIMPointSymbol":t.drawSymbol(s,{type:"point",x:0,y:0});break;case"CIMTextSymbol":break;case"CIMVectorMarker":{const i=new b;t.drawMarker(s,i);break}}return t.envelope()}class Bt{static getEnvelope(t){const s=new Jt;if(Array.isArray(t)){let i;for(const e of t)i?i.union(Yt(s,e)):i=Yt(s,e);return i}return Yt(s,t)}static getTextureAnchor(t){const s=this.getEnvelope(t);if(!s||s.width<=0||s.height<=0)return[0,0,0];const i=96/72,e=s.height*i+2;return[(s.x+.5*s.width)*i/(s.width*i+2),-(s.y+.5*s.height)*i/e,e]}static rasterize(t,s,i,e=!0){const r=i||this.getEnvelope(s);if(!r||r.width<=0||r.height<=0)return[null,0,0,0,0];const n=96/72,h=(r.x+.5*r.width)*n,o=(r.y+.5*r.height)*n;t.width=r.width*n,t.height=r.height*n,i||(t.width+=2,t.height+=2);const a=t.getContext("2d"),c=zt.createScale(n,-n);c.translate(.5*t.width-h,.5*t.height+o);const l=new _t(a,c);switch(s.type){case"CIMPointSymbol":l.drawSymbol(s,{type:"point",x:0,y:0});break;case"CIMVectorMarker":{const t=new b;l.drawMarker(s,t);break}}const u=a.getImageData(0,0,t.width,t.height),f=new Uint8Array(u.data);if(e){let t;for(let s=0;s<f.length;s+=4)t=f[s+3]/255,f[s]=f[s]*t,f[s+1]=f[s+1]*t,f[s+2]=f[s+2]*t}return[f,t.width,t.height,-h/t.width,-o/t.height]}static fromSimpleMarker(t){const s=50;let i,e;const r=t.style;if("circle"===r||"esriSMSCircle"===r){let t=Math.acos(.995),r=Math.ceil(Vt/t/4);0===r&&(r=1),t=$t/r,r*=4;const n=[];n.push([s,0]);for(let i=1;i<r;i++)n.push([s*Math.cos(i*t),-50*Math.sin(i*t)]);n.push([s,0]),i={rings:[n]},e={xmin:-50,ymin:-50,xmax:s,ymax:s}}else if("cross"===r||"esriSMSCross"===r){const t=0;i={rings:[[[t,s],[t,t],[s,t],[s,-t],[t,-t],[t,-50],[-t,-50],[-t,-t],[-50,-t],[-50,t],[-t,t],[-t,s],[t,s]]]},e={xmin:-50,ymin:-50,xmax:s,ymax:s}}else if("diamond"===r||"esriSMSDiamond"===r)i={rings:[[[-50,0],[0,s],[s,0],[0,-50],[-50,0]]]},e={xmin:-50,ymin:-50,xmax:s,ymax:s};else if("square"===r||"esriSMSSquare"===r)i={rings:[[[-50,-50],[-50,s],[s,s],[s,-50],[-50,-50]]]},e={xmin:-50,ymin:-50,xmax:s,ymax:s};else if("x"===r||"esriSMSX"===r){const t=0;i={rings:[[[0,t],[s-t,s],[s,s-t],[t,0],[s,t-s],[s-t,-50],[0,-t],[t-s,-50],[-50,t-s],[-t,0],[-50,s-t],[t-s,s],[0,t]]]},e={xmin:-50,ymin:-50,xmax:s,ymax:s}}else if("triangle"===r||"esriSMSTriangle"===r){const t=57.735026918962575,s=-t,r=2/3*100,n=r-100;i={rings:[[[s,n],[0,r],[t,n],[s,n]]]},e={xmin:s,ymin:n,xmax:t,ymax:r}}else"arrow"!==r&&"esriSMSArrow"!==r||(i={rings:[[[-50,50],[50,0],[-50,-50],[-33,-20],[-33,20],[-50,50]]]},e={xmin:-50,ymin:-50,xmax:s,ymax:s});let n;if(i&&e){const s=[{type:"CIMSolidFill",enable:!0,color:t.color}];t.outline&&s.push({type:"CIMSolidStroke",enable:!0,width:t.outline.width,color:t.outline.color}),n={type:"CIMPointSymbol",symbolLayers:[{type:"CIMVectorMarker",enable:!0,rotation:t.angle,size:t.size,offsetX:t.xoffset,offsetY:t.yoffset,frame:e,markerGraphics:[{type:"CIMMarkerGraphic",geometry:i,symbol:{type:"CIMPolygonSymbol",symbolLayers:s}}]}]}}return n}static fromCIMHatchFill(t){const s=void 0!==t.separation?t.separation:4,i=s/2;let e=this._getLineSymbolPeriod(t.lineSymbol)||4;for(;e<4;)e*=2;const r=e/2;return{type:"CIMVectorMarker",frame:{xmin:-r,xmax:r,ymin:-i,ymax:i},markerGraphics:[{type:"CIMMarkerGraphic",geometry:{paths:[[[-r,0],[r,0]]]},symbol:t.lineSymbol}],size:s}}static _getLineSymbolPeriod(t){if(t){const s=this._getEffectsRepeat(t.effects);if(s)return s;if(t.symbolLayers)for(const s of t.symbolLayers){const t=this._getEffectsRepeat(s.effects);if(t)return t;if(s){const t=this._getPlacementRepeat(s.markerPlacement);if(t)return t}}}return 0}static _getEffectsRepeat(t){if(t)for(const s of t)if(s)switch(s.type){case"CIMGeometricEffectDashes":{const t=s.dashTemplate;if(t&&t.length){let s=0;for(const i of t)s+=i;return 1&t.length&&(s*=2),s}break}case"CIMGeometricEffectWave":return s.period;default:Tt.error(`unsupported geometric effect type ${s.type}`)}return 0}static _getPlacementRepeat(t){if(t)switch(t.type){case"CIMMarkerPlacementAlongLineSameSize":case"CIMMarkerPlacementAlongLineRandomSize":case"CIMMarkerPlacementAlongLineVariableSize":{const s=t.placementTemplate;if(s&&s.length){let t=0;for(const i of s)t+=i;return 1&s.length&&(t*=2),t}break}}return 0}static fromCIMInsidePolygon(t){const s=t.markerPlacement,i=s.stepX/2,e=s.stepY/2,r={xmin:-i,xmax:i,ymin:-e,ymax:e},n={type:t.type,...t};return n.markerPlacement=null,n.anchorPoint=null,{type:"CIMVectorMarker",frame:r,markerGraphics:[{type:"CIMMarkerGraphic",geometry:{x:0,y:0},symbol:{type:"CIMPointSymbol",symbolLayers:[n]}}],size:s.stepY}}static getFillColor(t){if(!t)return null;switch(t.type){case"CIMPolygonSymbol":if(t.symbolLayers)for(const s of t.symbolLayers){const t=Bt.getFillColor(s);if(null!=t)return t}break;case"CIMTextSymbol":return Bt.getFillColor(t.symbol);case"CIMSolidFill":return t.color}}static getStrokeColor(t){if(t)switch(t.type){case"CIMPolygonSymbol":case"CIMLineSymbol":if(t.symbolLayers)for(const s of t.symbolLayers){const t=Bt.getStrokeColor(s);if(void 0!==t)return t}break;case"CIMTextSymbol":return Bt.getStrokeColor(t.symbol);case"CIMSolidStroke":return t.color}}static getStrokeWidth(t){if(t)switch(t.type){case"CIMPolygonSymbol":case"CIMLineSymbol":if(t.symbolLayers)for(const s of t.symbolLayers){const t=Bt.getStrokeWidth(s);if(void 0!==t)return t}break;case"CIMTextSymbol":return Bt.getStrokeWidth(t.symbol);case"CIMSolidStroke":case"CIMGradientStroke":case"CIMPictureStroke":return t.width}}static getSize(t){if(t)switch(t.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":{let s=0;if(t.symbolLayers)for(const i of t.symbolLayers){const t=Bt.getSize(i);t>s&&(s=t)}return s}case"CIMSolidStroke":case"CIMPictureStroke":case"CIMGradientStroke":return t.width;case"CIMCharacterMarker":case"CIMPictureMarker":case"CIMVectorMarker":return t.size}}static getMarkerScaleRatio(t){if(t)switch(t.type){case"CIMVectorMarker":if(!1!==t.scaleSymbolsProportionally&&t.frame)return t.size/(t.frame.ymax-t.frame.ymin)}return 1}}class qt{static rasterizeSimpleFill(t,s,i){"solid"!==s&&"none"!==s&&"esriSFSSolid"!==s&&"esriSFSNull"!==s||console.error("Unexpected: style does not require rasterization");const e=a(Math.ceil(i)),r=this._isHorizontalOrVertical(s)?8*e:16*e,n=2*e;t.width=r,t.height=r;const h=t.getContext("2d");h.strokeStyle="#FFFFFF",h.lineWidth=e,h.beginPath(),"vertical"!==s&&"cross"!==s&&"esriSFSCross"!==s&&"esriSFSVertical"!==s||(h.moveTo(r/2,-n),h.lineTo(r/2,r+n)),"horizontal"!==s&&"cross"!==s&&"esriSFSCross"!==s&&"esriSFSHorizontal"!==s||(h.moveTo(-n,r/2),h.lineTo(r+n,r/2)),"forward-diagonal"!==s&&"diagonal-cross"!==s&&"esriSFSDiagonalCross"!==s&&"esriSFSForwardDiagonal"!==s||(h.moveTo(-n,-n),h.lineTo(r+n,r+n),h.moveTo(r-n,-n),h.lineTo(r+n,n),h.moveTo(-n,r-n),h.lineTo(n,r+n)),"backward-diagonal"!==s&&"diagonal-cross"!==s&&"esriSFSBackwardDiagonal"!==s&&"esriSFSDiagonalCross"!==s||(h.moveTo(r+n,-n),h.lineTo(-n,r+n),h.moveTo(n,-n),h.lineTo(-n,n),h.moveTo(r+n,r-n),h.lineTo(r-n,r+n)),h.stroke();const o=h.getImageData(0,0,t.width,t.height),c=new Uint8Array(o.data);let l;for(let t=0;t<c.length;t+=4)l=c[t+3]/255,c[t]=c[t]*l,c[t+1]=c[t+1]*l,c[t+2]=c[t+2]*l;return[c,t.width,t.height]}static rasterizeSimpleLine(t,s){let i;switch(s){case"butt":i="Butt";break;case"square":i="Square";break;default:i="Round"}const e="Butt"===i;let r;switch(t){case"dash":case"esriSLSDash":r=e?[4,3]:[3,4];break;case"dash-dot":case"esriSLSDashDot":r=e?[4,3,1,3]:[3,4,0,4];break;case"dot":case"esriSLSDot":r=e?[1,3]:[0,4];break;case"long-dash":case"esriSLSLongDash":r=e?[8,3]:[7,4];break;case"long-dash-dot":case"esriSLSLongDashDot":r=e?[8,3,1,3]:[7,4,0,4];break;case"long-dash-dot-dot":case"esriSLSDashDotDot":r=e?[8,3,1,3,1,3]:[7,4,0,4,0,4];break;case"short-dash":case"esriSLSShortDash":r=e?[4,1]:[3,2];break;case"short-dash-dot":case"esriSLSShortDashDot":r=e?[4,1,1,1]:[3,2,0,2];break;case"short-dash-dot-dot":case"esriSLSShortDashDotDot":r=e?[4,1,1,1,1,1]:[3,2,0,2,0,2];break;case"short-dot":case"esriSLSShortDot":r=e?[1,1]:[0,2];break;case"solid":case"esriSLSSolid":case"none":Tt.error("Unexpected: style does not require rasterization"),r=[0,0];break;default:Tt.error(`Tried to rasterize SLS, but found an unexpected style: ${t}!`),r=[0,0]}return this.rasterizeDash(r,i)}static rasterizeDash(t,s){const i="Butt"===s,e="Square"===s,r=!i&&!e;let n=0;for(const s of t)n+=s;const h=15*n,o=31*h,a=new Float32Array(o),c=r?225:15;for(let t=0;t<o;++t)a[t]=c;const l=7.5;let u=0,f=0,d=!0;for(const s of t){u=f,f+=15*s;let t=u;for(;t<f;){let s=0;for(;s<31;){const n=s*h+t,o=r?(s-15)*(s-15):Math.abs(s-15);a[n]=d?i?Math.max(Math.max(u+l-t,o),Math.max(t-f+l,o)):o:r?Math.min((t-u)*(t-u)+o,(t-f)*(t-f)+o):e?Math.min(Math.max(t-u,o),Math.max(f-t,o)):Math.min(Math.max(t-u+l,o),Math.max(f+l-t,o)),s++}t++}d=!d}const M=a.length,m=new Uint8Array(4*M);for(let t=0;t<M;++t)Xt((r?Math.sqrt(a[t]):a[t])/15,m,4*t);return[m,h,31]}static _isHorizontalOrVertical(t){return"vertical"===t||"horizontal"===t||"cross"===t||"esriSFSCross"===t||"esriSFSVertical"===t||"esriSFSHorizontal"===t}}class Wt{static findApplicableOverrides(t,s,i){if(s){if(t.primitiveName){let e=!1;for(const s of i)if(s.primitiveName===t.primitiveName){e=!0;break}if(!e)for(const e of s)e.primitiveName===t.primitiveName&&i.push(e)}switch(t.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(t.effects)for(const e of t.effects)Wt.findApplicableOverrides(e,s,i);if(t.symbolLayers)for(const e of t.symbolLayers)Wt.findApplicableOverrides(e,s,i);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMPictureStroke":case"CIMGradientStroke":case"CIMSolidFill":case"CIMPictureFill":case"CIMHatchFill":case"CIMGradientFill":case"CIMVectorMarker":case"CIMCharacterMarker":case"CIMPictureMarker":if(t.effects)for(const e of t.effects)Wt.findApplicableOverrides(e,s,i);if(t.markerPlacement&&Wt.findApplicableOverrides(t.markerPlacement,s,i),"CIMVectorMarker"===t.type){if(t.markerGraphics)for(const e of t.markerGraphics)Wt.findApplicableOverrides(e,s,i),Wt.findApplicableOverrides(e.symbol,s,i)}else"CIMCharacterMarker"===t.type?Wt.findApplicableOverrides(t.symbol,s,i):"CIMHatchFill"===t.type&&Wt.findApplicableOverrides(t.lineSymbol,s,i)}}}static applyOverrides(t,s,i,e){if(s){if(t.primitiveName)for(const n of s)if(n.primitiveName===t.primitiveName){const s=(r=n.propertyName)?r.charAt(0).toLowerCase()+r.substr(1):r;if(e&&e.push({cim:t,nocapPropertyName:s,value:t[s]}),n.expression&&(n.value=Wt.toValue(n.propertyName,n.expression)),i){let s=!1;for(const e of i)e.primitiveName===t.primitiveName&&(s=!0);s||i.push(n)}t[s]=n.value}var r;switch(t.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(t.effects)for(const r of t.effects)Wt.applyOverrides(r,s,i,e);if(t.symbolLayers)for(const r of t.symbolLayers)Wt.applyOverrides(r,s,i,e);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMSolidFill":case"CIMVectorMarker":if(t.effects)for(const r of t.effects)Wt.applyOverrides(r,s,i,e);if("CIMVectorMarker"===t.type&&t.markerGraphics)for(const r of t.markerGraphics)Wt.applyOverrides(r,s,i,e),Wt.applyOverrides(r.symbol,s,i,e)}}}static restoreOverrides(t){for(const s of t)s.cim[s.nocapPropertyName]=s.value}static buildOverrideKey(t){let s="";for(const i of t)void 0!==i.value&&(s+=`${i.primitiveName}${i.propertyName}${JSON.stringify(i.value)}`);return s}static toValue(t,s){if("DashTemplate"===t)return s.split(" ").map((t=>Number(t)));if("Color"===t){const t=new c(s).toRgba();return t[3]*=255,t}return s}}function Ut(t){if(!t)return null;switch(t.type){case"CIMPointSymbol":{const s=t.symbolLayers;return s&&1===s.length?Ut(s[0]):null}case"CIMVectorMarker":{const s=t.markerGraphics;if(!s||1!==s.length)return null;const i=s[0];if(!i)return null;const e=i.geometry;if(!e)return null;const r=i.symbol;return!r||"CIMPolygonSymbol"!==r.type&&"CIMLineSymbol"!==r.type?null:{geom:e,asFill:"CIMPolygonSymbol"===r.type}}case"sdf":return{geom:t.geom,asFill:t.asFill}}return null}function jt(t){let s=1/0,i=-1/0,e=1/0,r=-1/0;for(const n of t)for(const t of n)t[0]<s&&(s=t[0]),t[0]>i&&(i=t[0]),t[1]<e&&(e=t[1]),t[1]>r&&(r=t[1]);return[s,e,i,r]}function Kt(t){return t?t.rings?jt(t.rings):t.paths?jt(t.paths):r(t)?[t.xmin,t.ymin,t.xmax,t.ymax]:null:null}function Zt(t,s,i,e,r){const[n,h,o,a]=t;if(o<n||a<h)return[0,0,0];const c=o-n,l=a-h,u=Math.floor(31.5),f=(128-2*(u+1))/Math.max(c,l),d=Math.round(c*f)+2*u,M=Math.round(l*f)+2*u;let m=1;s&&(m=M/f/(s.ymax-s.ymin));let S=0,y=0;return e&&(r?s&&i&&s.ymax-s.ymin>0&&(S=e.x/(i*((s.xmax-s.xmin)/(s.ymax-s.ymin))),y=e.y/i):(S=e.x,y=e.y)),S=.5*(s.xmax+s.xmin)+S*(s.xmax-s.xmin),y=.5*(s.ymax+s.ymin)+y*(s.ymax-s.ymin),S-=n,y-=h,S*=f,y*=f,S+=u,y+=u,[m,S/d-.5,-(y/M-.5)]}function Qt(t){const s=(i=t.geom)?i.rings?i.rings:i.paths?i.paths:void 0!==i.xmin&&void 0!==i.ymin&&void 0!==i.xmax&&void 0!==i.ymax?[[[i.xmin,i.ymin],[i.xmin,i.ymax],[i.xmax,i.ymax],[i.xmax,i.ymin],[i.xmin,i.ymin]]]:null:null;var i;const e=function(t){let s=1/0,i=-1/0,e=1/0,r=-1/0;for(const n of t)for(const t of n)t[0]<s&&(s=t[0]),t[0]>i&&(i=t[0]),t[1]<e&&(e=t[1]),t[1]>r&&(r=t[1]);return new At(s,e,i-s,r-e)}(s),r=Math.floor(31.5),n=(128-2*(r+1))/Math.max(e.width,e.height),h=Math.round(e.width*n)+2*r,o=Math.round(e.height*n)+2*r,a=[];for(const i of s)if(i&&i.length>1){const s=[];for(const t of i){let[i,h]=t;i-=e.x,h-=e.y,i*=n,h*=n,i+=r-.5,h+=r-.5,s.push([i,h])}if(t.asFill){const t=s.length-1;s[0][0]===s[t][0]&&s[0][1]===s[t][1]||s.push(s[0])}a.push(s)}const c=function(t,s,i,e){const r=s*i,n=new Array(r),h=e*e+1;for(let t=0;t<r;++t)n[t]=h;for(const r of t){const t=r.length;for(let h=1;h<t;++h){const t=r[h-1],o=r[h];let a,c,l,u;t[0]<o[0]?(a=t[0],c=o[0]):(a=o[0],c=t[0]),t[1]<o[1]?(l=t[1],u=o[1]):(l=o[1],u=t[1]);let f=Math.floor(a)-e,d=Math.floor(c)+e,M=Math.floor(l)-e,m=Math.floor(u)+e;f<0&&(f=0),d>s&&(d=s),M<0&&(M=0),m>i&&(m=i);const S=o[0]-t[0],y=o[1]-t[1],C=S*S+y*y;for(let e=f;e<d;e++)for(let r=M;r<m;r++){let h,a,c=(e-t[0])*S+(r-t[1])*y;c<0?(h=t[0],a=t[1]):c>C?(h=o[0],a=o[1]):(c/=C,h=t[0]+c*S,a=t[1]+c*y);const l=(e-h)*(e-h)+(r-a)*(r-a),u=(i-r-1)*s+e;l<n[u]&&(n[u]=l)}}}for(let t=0;t<r;++t)n[t]=Math.sqrt(n[t]);return n}(a,h,o,r);return t.asFill&&function(t,s,i,e,r){for(const n of t){const t=n.length;for(let h=1;h<t;++h){const t=n[h-1],o=n[h];let a,c,l,u;t[0]<o[0]?(a=t[0],c=o[0]):(a=o[0],c=t[0]),t[1]<o[1]?(l=t[1],u=o[1]):(l=o[1],u=t[1]);let f=Math.floor(a),d=Math.floor(c)+1,M=Math.floor(l),m=Math.floor(u)+1;f<e&&(f=e),d>s-e&&(d=s-e),M<e&&(M=e),m>i-e&&(m=i-e);for(let n=M;n<m;++n){if(t[1]>n==o[1]>n)continue;const h=(i-n-1)*s;for(let s=f;s<d;++s)s<(o[0]-t[0])*(n-t[1])/(o[1]-t[1])+t[0]&&(r[h+s]=-r[h+s]);for(let t=e;t<f;++t)r[h+t]=-r[h+t]}}}}(a,h,o,r,c),[ts(c,r),h,o]}function ts(t,s){const i=2*s,e=t.length,r=new Uint8Array(4*e);for(let s=0;s<e;++s)Xt(.5-t[s]/i,r,4*s);return r}const ss=o.getLogger("esri.symbols.cim.cimAnalyzer");function is(t){switch(t){case"Butt":return 0;case"Square":return 2;case"Round":default:return 1}}function es(t){switch(t){case"Bevel":return 0;case"Miter":return 2;case"Round":default:return 1}}function rs(t){switch(t){case"Left":default:return"left";case"Right":return"right";case"Center":return"center";case"Justify":return"justify"}}function ns(t){switch(t){case"Top":default:return"top";case"Center":return"middle";case"Baseline":return"baseline";case"Bottom":return"bottom"}}function hs(t,s,i,e){let r;t[s]?r=t[s]:(r={},t[s]=r),r[i]=e}function os(t){const s=t.markerPlacement;return s&&s.angleToLine?1:0}async function as(t,s,i,e){const r=i||[];if(!t)return r;let n,h;const o={};if("CIMSymbolReference"!==t.type)return ss.error("Expect cim type to be 'CIMSymbolReference'"),r;if(n=t.symbol,h=t.primitiveOverrides,h){const t=[];for(const i of h){const e=i.valueExpressionInfo;if(e&&s){const r=l(e.expression,s.spatialReference,s.fields).then((t=>{t&&hs(o,i.primitiveName,i.propertyName,t)}));t.push(r)}else null!=i.value&&hs(o,i.primitiveName,i.propertyName,i.value)}await u(t)}switch(n.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":!function(t,s,i,e,r,n){if(!t)return;const h=t.symbolLayers;if(!h)return;let o;const a=Bt.getSize(t);"CIMPointSymbol"===t.type&&"Map"===t.angleAlignment&&(o=1);let c=h.length;for(;c--;){const l=h[c];if(!l||!1===l.enable)continue;const u=[];switch(Wt.findApplicableOverrides(l,s,u),l.type){case"CIMSolidFill":cs(l,i,u,e,r);break;case"CIMPictureFill":ls(l,i,u,e,r);break;case"CIMHatchFill":us(l,i,u,e,r);break;case"CIMGradientFill":fs(l,i,u,e,r);break;case"CIMSolidStroke":ds(l,i,u,e,r,"CIMPolygonSymbol"===t.type,a);break;case"CIMPictureStroke":Ms(l,i,u,e,r,"CIMPolygonSymbol"===t.type,a);break;case"CIMGradientStroke":ms(l,i,u,e,r,"CIMPolygonSymbol"===t.type,a);break;case"CIMCharacterMarker":if(Ss(l,i,u,e,r))break;break;case"CIMPictureMarker":if(Ss(l,i,u,e,r))break;"CIMLineSymbol"===t.type&&(o=os(l)),ys(l,i,u,e,r,o,a);break;case"CIMVectorMarker":if(Ss(l,i,u,e,r))break;"CIMLineSymbol"===t.type&&(o=os(l)),Cs(l,i,u,e,r,o,a,n);break;default:ss.error("Cannot analyze CIM layer",l.type)}}}(n,h,o,s,r,e)}return r}function cs(t,s,i,e,r){const n=t.primitiveName,h=d(t.color),o=f(JSON.stringify(t)).toString();r.push({type:"fill",templateHash:o,materialHash:0===i.length?o:()=>o,cim:t,materialOverrides:null,colorLocked:t.colorLocked,color:Is(n,s,"Color",e,h,ws),height:0,angle:0,offsetX:0,offsetY:0,scaleX:1,effects:t.effects})}function ls(t,s,i,e,r){const n=t.primitiveName,h=t.tintColor?d(t.tintColor):{r:255,g:255,b:255,a:1},o=f(JSON.stringify(t)).toString(),a=f(`${t.url}${JSON.stringify(t.colorSubstitutions)}`).toString();r.push({type:"fill",templateHash:o,materialHash:0===i.length?a:()=>a,cim:t,materialOverrides:null,colorLocked:t.colorLocked,effects:t.effects,color:Is(n,s,"TintColor",e,h,ws),height:Is(n,s,"Height",e,t.height),scaleX:Is(n,s,"ScaleX",e,t.scaleX),angle:Is(n,s,"Rotation",e,t.rotation),offsetX:Is(n,s,"OffsetX",e,t.offsetX),offsetY:Is(n,s,"OffsetY",e,t.offsetY)})}function us(t,s,i,e,r){const n=["Rotation","OffsetX","OffsetY"],h=i.filter((s=>s.primitiveName!==t.primitiveName&&-1===n.indexOf(s.propertyName))),o=t.primitiveName,a=f(JSON.stringify(t)).toString(),c=f(`${t.separation}${JSON.stringify(t.lineSymbol)}`).toString();r.push({type:"fill",templateHash:a,materialHash:0===i.length?c:xs(c,s,h,e),cim:t,materialOverrides:h,colorLocked:t.colorLocked,effects:t.effects,color:{r:255,g:255,b:255,a:1},height:Is(o,s,"Separation",e,t.separation),scaleX:1,angle:Is(o,s,"Rotation",e,t.rotation),offsetX:Is(o,s,"OffsetX",e,t.offsetX),offsetY:Is(o,s,"OffsetY",e,t.offsetY)})}function fs(t,s,i,e,r){const n=f(JSON.stringify(t)).toString();r.push({type:"fill",templateHash:n,materialHash:0===i.length?n:xs(n,s,i,e),cim:t,materialOverrides:null,colorLocked:t.colorLocked,effects:t.effects,color:{r:128,g:128,b:128,a:1},height:0,angle:0,offsetX:0,offsetY:0,scaleX:1})}function ds(t,s,i,e,r,n,h){const o=f(JSON.stringify(t)).toString(),a=t.primitiveName,c=d(t.color),l=void 0!==t.width?t.width:4,u=is(t.capStyle),M=es(t.joinStyle),m=t.miterLimit;r.push({type:"line",templateHash:o,materialHash:0===i.length?o:()=>o,cim:t,materialOverrides:null,isOutline:n,colorLocked:t.colorLocked,effects:t.effects,color:Is(a,s,"Color",e,c,ws),width:Is(a,s,"Width",e,l),cap:Is(a,s,"CapStyle",e,u),join:Is(a,s,"JoinStyle",e,M),miterLimit:Is(a,s,"MiterLimit",e,m),referenceWidth:h,zOrder:gs(t.name),isDashed:!1})}function Ms(t,s,i,e,r,n,h){const o=f(`${t.url}${JSON.stringify(t.colorSubstitutions)}`).toString(),a=t.primitiveName,c=d(t.tintColor),l=void 0!==t.width?t.width:4,u=is(t.capStyle),M=es(t.joinStyle),m=t.miterLimit,S=f(JSON.stringify(t)).toString();r.push({type:"line",templateHash:S,materialHash:0===i.length?o:()=>o,cim:t,materialOverrides:null,isOutline:n,colorLocked:t.colorLocked,effects:t.effects,color:Is(a,s,"TintColor",e,c,ws),width:Is(a,s,"Width",e,l),cap:Is(a,s,"CapStyle",e,u),join:Is(a,s,"JoinStyle",e,M),miterLimit:Is(a,s,"MiterLimit",e,m),referenceWidth:h,zOrder:gs(t.name),isDashed:!1})}function ms(t,s,i,e,r,n,h){const o=t.primitiveName,a=void 0!==t.width?t.width:4,c=is(t.capStyle),l=es(t.joinStyle),u=t.miterLimit,d=f(JSON.stringify(t)).toString();r.push({type:"line",templateHash:d,materialHash:0===i.length?d:xs(d,s,i,e),cim:t,materialOverrides:null,isOutline:n,colorLocked:t.colorLocked,effects:t.effects,color:{r:128,g:128,b:128,a:1},width:Is(o,s,"Width",e,a),cap:Is(o,s,"CapStyle",e,c),join:Is(o,s,"JoinStyle",e,l),miterLimit:Is(o,s,"MiterLimit",e,u),referenceWidth:h,zOrder:gs(t.name),isDashed:!1})}function Ss(t,s,i,e,r){const n=t.markerPlacement;if(!n||"CIMMarkerPlacementInsidePolygon"!==n.type)return!1;const h=n,o=["Rotation","OffsetX","OffsetY"],a=i.filter((s=>s.primitiveName!==t.primitiveName&&-1===o.indexOf(s.propertyName))),c=f(JSON.stringify(t)).toString();return r.push({type:"fill",templateHash:c,materialHash:0===i.length?c:xs(c,s,a,e),cim:t,materialOverrides:a,colorLocked:t.colorLocked,effects:t.effects,color:{r:255,g:255,b:255,a:1},height:Is(h.primitiveName,s,"StepY",e,h.stepY),scaleX:1,angle:Is(h.primitiveName,s,"GridAngle",e,h.gridAngle),offsetX:Is(h.primitiveName,s,"OffsetX",e,h.offsetX),offsetY:Is(h.primitiveName,s,"OffsetY",e,h.offsetY)}),!0}function ys(t,s,i,e,r,n,h){const o=t.primitiveName,a=t.size,c=t.scaleX,l=t.rotation,u=t.offsetX,M=t.offsetY,m=d(t.tintColor),S=f(`${t.url}${JSON.stringify(t.colorSubstitutions)}`).toString();let y=!1,C="";for(const t of i)t.primitiveName===o&&(void 0!==t.value?C+=`-${t.primitiveName}-${t.propertyName}-${JSON.stringify(t.value)}`:t.valueExpressionInfo&&(y=!0));r.push({type:"marker",templateHash:f(JSON.stringify(t)+C).toString(),materialHash:y?()=>S:S,cim:t,materialOverrides:null,colorLocked:t.colorLocked,effects:t.effects,scaleSymbolsProportionally:!1,alignment:n,size:Is(o,s,"Size",e,a),scaleX:Is(o,s,"ScaleX",e,c),rotation:Is(o,s,"Rotation",e,l),offsetX:Is(o,s,"OffsetX",e,u),offsetY:Is(o,s,"OffsetY",e,M),color:Is(o,s,"TintColor",e,m,ws),anchorPoint:t.anchorPoint,isAbsoluteAnchorPoint:"Relative"!==t.anchorPointUnits,outlineColor:{r:0,g:0,b:0,a:0},outlineWidth:0,frameHeight:0,rotateClockwise:t.rotateClockwise,referenceSize:h,sizeRatio:1,markerPlacement:t.markerPlacement})}function Cs(t,s,i,e,r,n,h,o){const a=t.markerGraphics;if(!a)return;let c=0;if(t.scaleSymbolsProportionally){const s=t.frame;s&&(c=s.ymax-s.ymin)}for(const l of a)if(l){const a=l.symbol;if(!a)continue;switch(a.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":ks(t,l,i,s,e,r,n,h,c,o);break;case"CIMTextSymbol":bs(t,l,s,i,e,r,n,h,c)}}}function bs(t,s,i,e,r,n,h,o,a){Wt.findApplicableOverrides(s,e,[]);const c=s.geometry;if(!("x"in c)||!("y"in c))return;const l=s.symbol,u=(M=l).underline?"underline":M.strikethrough?"line-through":"none";var M;const m=function(t){let s="normal",i="normal";if(t){const e=t.toLowerCase();-1!==e.indexOf("italic")?s="italic":-1!==e.indexOf("oblique")&&(s="oblique"),-1!==e.indexOf("bold")?i="bold":-1!==e.indexOf("light")&&(i="lighter")}return{style:s,weight:i}}(l.fontStyleName);l.font={family:l.fontFamilyName,decoration:u,...m};const S=t.frame,C=t.size/a,b=t.primitiveName,k=(l.height||0)*C,p=l.angle||0,g=((l.offsetX||0)+(c.x-.5*(S.xmin+S.xmax)))*C,w=((l.offsetY||0)+(c.y-.5*(S.ymin+S.ymax)))*C,I=d(Bt.getFillColor(l));let x=d(Bt.getStrokeColor(l)),v=Bt.getStrokeWidth(l);v||(x=d(Bt.getFillColor(l.haloSymbol)),v=l.haloSize*C);let P="";for(const t of e)t.primitiveName===b&&void 0!==t.value&&(P+=`-${t.primitiveName}-${t.propertyName}-${JSON.stringify(t.value)}`);const O=JSON.stringify(t.effects)+Number(t.colorLocked)+JSON.stringify(t.anchorPoint)+t.anchorPointUnits+JSON.stringify(t.markerPlacement),L=f(JSON.stringify(s)+O+P).toString();n.push({type:"text",templateHash:L,materialHash:()=>f(JSON.stringify(l.font)).toString(),cim:l,materialOverrides:null,colorLocked:t.colorLocked,effects:t.effects,alignment:h,anchorPoint:{x:t.anchorPoint?t.anchorPoint.x:0,y:t.anchorPoint?t.anchorPoint.y:0},isAbsoluteAnchorPoint:"Relative"!==t.anchorPointUnits,fontName:l.fontFamilyName,decoration:"none",weight:"normal",style:"normal",size:Is(b,i,"Size",r,k),angle:Is(b,i,"Rotation",r,p),offsetX:Is(b,i,"OffsetX",r,g),offsetY:Is(b,i,"OffsetY",r,w),horizontalAlignment:rs(l.horizontalAlignment),verticalAlignment:ns(l.verticalAlignment),text:Is(s.primitiveName,i,"TextString",r,s.textString,y,l.textCase),color:I,outlineColor:x,outlineSize:v,referenceSize:o,sizeRatio:1,markerPlacement:t.markerPlacement})}function ks(t,s,i,e,r,n,h,o,a,c){const l=s.geometry;if(!l)return;const u=s.symbol.symbolLayers;if(!u)return;if(c)return void ps(t,s,e,i,r,n,h,o,a);let M=u.length;for(;M--;){const c=u[M];if(c&&!1!==c.enable)switch(c.type){case"CIMSolidFill":case"CIMSolidStroke":{const u=Kt(l);if(!u)continue;const[M,m,S]=Zt(u,t.frame,t.size,t.anchorPoint,"Relative"!==t.anchorPointUnits),y="CIMSolidFill"===c.type,C={type:"sdf",geom:l,asFill:y},b=t.primitiveName,k=t.size,p=t.rotation||0,g=t.offsetX,w=t.offsetY,I=c.primitiveName,x=d(y?Bt.getFillColor(c):Bt.getStrokeColor(c)),v=y?{r:0,g:0,b:0,a:0}:d(Bt.getStrokeColor(c)),P=Bt.getStrokeWidth(c);if(!y&&!P)break;let O=!1,L="";for(const t of i)t.primitiveName!==I&&t.primitiveName!==b||(void 0!==t.value?L+=`-${t.primitiveName}-${t.propertyName}-${JSON.stringify(t.value)}`:t.valueExpressionInfo&&(O=!0));const F=JSON.stringify({...t,markerGraphics:null}),A=f(JSON.stringify(C)).toString(),N={type:"marker",templateHash:f(JSON.stringify(s)+JSON.stringify(c)+F+L).toString(),materialHash:O?()=>A:A,cim:C,materialOverrides:null,colorLocked:t.colorLocked,effects:t.effects,scaleSymbolsProportionally:t.scaleSymbolsProportionally,alignment:h,anchorPoint:{x:m,y:S},isAbsoluteAnchorPoint:!1,size:Is(t.primitiveName,e,"Size",r,k),rotation:Is(t.primitiveName,e,"Rotation",r,p),offsetX:Is(t.primitiveName,e,"OffsetX",r,g),offsetY:Is(t.primitiveName,e,"OffsetY",r,w),scaleX:1,frameHeight:a,rotateClockwise:t.rotateClockwise,referenceSize:o,sizeRatio:M,color:Is(I,e,"Color",r,x,ws),outlineColor:Is(I,e,"Color",r,v,ws),outlineWidth:Is(I,e,"Width",r,P),markerPlacement:t.markerPlacement};n.push(N);break}default:ps(t,s,e,i,r,n,h,o,a)}}}function ps(t,s,i,e,r,n,h,o,a){const c=function(t,s){return{type:t.type,enable:!0,name:t.name,colorLocked:t.colorLocked,primitiveName:t.primitiveName,anchorPoint:t.anchorPoint,anchorPointUnits:t.anchorPointUnits,offsetX:0,offsetY:0,rotateClockwise:t.rotateClockwise,rotation:0,size:t.size,billboardMode3D:t.billboardMode3D,depth3D:t.depth3D,frame:t.frame,markerGraphics:[s],scaleSymbolsProportionally:t.scaleSymbolsProportionally,respectFrame:t.respectFrame,clippingPath:t.clippingPath,effects:t.effects}}(t,s);let l=[];const u=["Rotation","OffsetX","OffsetY"];l=e.filter((s=>s.primitiveName!==t.primitiveName||-1===u.indexOf(s.propertyName)));let d="";for(const t of e)void 0!==t.value&&(d+=`-${t.primitiveName}-${t.propertyName}-${JSON.stringify(t.value)}`);const[m,S,y]=Bt.getTextureAnchor(c),C=t.primitiveName,b=t.rotation||0,k=t.offsetX||0,p=t.offsetY||0,g=f(JSON.stringify(c)+d).toString(),w={type:"marker",templateHash:g,materialHash:0===l.length?g:xs(g,i,l,r),cim:c,materialOverrides:l,colorLocked:t.colorLocked,effects:t.effects,scaleSymbolsProportionally:t.scaleSymbolsProportionally,alignment:h,anchorPoint:{x:m,y:S},isAbsoluteAnchorPoint:!1,size:t.size,rotation:Is(C,i,"Rotation",r,b),offsetX:Is(C,i,"OffsetX",r,k),offsetY:Is(C,i,"OffsetY",r,p),color:{r:0,g:0,b:0,a:0},outlineColor:{r:0,g:0,b:0,a:0},outlineWidth:0,scaleX:1,frameHeight:a,rotateClockwise:t.rotateClockwise,referenceSize:o,sizeRatio:y/M(t.size),markerPlacement:t.markerPlacement};n.push(w)}function gs(t){if(t&&0===t.indexOf("Level_")){const s=parseInt(t.substr(6),10);if(NaN!==s)return s}return 0}function ws(t){if(!t||0===t.length)return null;const s=new c(t).toRgba();return{r:s[0],g:s[1],b:s[2],a:s[3]}}function Is(t,s,i,e,r,n,h){const o=s[t];if(o){const t=o[i];if("string"==typeof t||"number"==typeof t||t instanceof Array)return n?n.call(null,t,h):t;if(null!=t&&t instanceof m)return(s,i,o)=>{let a=S(t,s,{$view:o},e.geometryType,i);return null!==a&&n&&(a=n.call(null,a,h)),null!==a?a:r}}return r}function xs(t,s,i,e){for(const t of i)if(t.valueExpressionInfo){const i=s[t.primitiveName]&&s[t.primitiveName][t.propertyName];i instanceof m&&(t.fn=(t,s,r)=>S(i,t,{$view:r},e.geometryType,s))}return(s,e,r)=>{for(const t of i)t.fn&&(t.value=t.fn(s,e,r));return f(t+Wt.buildOverrideKey(i)).toString()}}function vs(t,s){if(!s||0===s.length)return t;const i=JSON.parse(JSON.stringify(t));return Wt.applyOverrides(i,s),i}export{Ft as A,Lt as G,as as N,At as a,k as b,Qt as f,qt as h,vs as j,p as o,v as p,Ut as r,Bt as y}