import{l as t,D as e,E as s,K as r,aS as i,b7 as n,B as a}from"./p-dc4230e0.js";import{b as o}from"./p-05aa0405.js";function l(t){return t&&"group"===t.type}function d(t,e,s){let r,i;if(t)for(let n=0,a=t.length;n<a;n++){if(r=t.getItemAt(n),r[e]===s)return r;if(l(r)&&(i=d(r.layers,e,s),i))return i}}const h=t.getLogger("esri.support.LayersMixin"),u=t=>{let l=class extends t{constructor(...t){super(...t),this.layers=new i;const e=t=>{t.parent=this,this.layerAdded(t),"elevation"!==t.type&&"base-elevation"!==t.type||h.error(`Layer 'title:${t.title}, id:${t.id}' of type '${t.type}' is not supported as an operational layer and will therefore be ignored.`)},s=t=>{t.parent=null,this.layerRemoved(t)};this.layers.on("before-add",(t=>{var e;(e=t.item).parent&&"remove"in e.parent&&e.parent.remove(e)})),this.layers.on("after-add",(t=>e(t.item))),this.layers.on("after-remove",(t=>s(t.item)))}destroy(){const t=this.layers.removeAll();for(const e of t)this.layerRemoved(e),e.destroy();this.layers.destroy()}set layers(t){this._set("layers",n(t,this._get("layers")))}add(t,e){const s=this.layers;e=s.getNextIndex(e),t instanceof o?t.parent===this?this.reorder(t,e):s.add(t,e):a(t)?t.then((t=>{this.destroyed||this.add(t,e)})):h.error("#add()","The item being added is not a Layer or a Promise that resolves to a Layer.")}addMany(t,e){const s=this.layers;e=s.getNextIndex(e),t.slice().forEach((t=>{t.parent!==this?(s.add(t,e),e+=1):this.reorder(t,e)}))}findLayerById(t){return d(this.layers,"id",t)}findLayerByUid(t){return d(this.layers,"uid",t)}remove(t){return this.layers.remove(t)}removeMany(t){return this.layers.removeMany(t)}removeAll(){return this.layers.removeAll()}reorder(t,e){return this.layers.reorder(t,e)}layerAdded(t){}layerRemoved(t){}};return e([s()],l.prototype,"layers",null),l=e([r("esri.support.LayersMixin")],l),l},f=t.getLogger("esri.support.TablesMixin");function y(t){return t&&"group"===t.type}function c(t,e,s){if(t)for(let r=0,i=t.length;r<i;r++){const i=t.getItemAt(r);if(i[e]===s)return i;if(y(i)){const t=c(i.tables,e,s);if(t)return t}}}const p=t=>{let a=class extends t{constructor(...t){super(...t),this.tables=new i,this.tables.on("after-add",(t=>{const e=t.item;e.parent&&e.parent!==this&&"tables"in e.parent&&e.parent.tables.remove(e),e.parent=this,"feature"!==e.type&&f.error(`Layer 'title:${e.title}, id:${e.id}' of type '${e.type}' is not supported as a table and will therefore be ignored.`)})),this.tables.on("after-remove",(t=>{t.item.parent=null}))}destroy(){const t=this.tables.removeAll();for(const e of t)e.destroy();this.tables.destroy()}set tables(t){this._set("tables",n(t,this._get("tables")))}findTableById(t){return c(this.tables,"id",t)}findTableByUid(t){return c(this.tables,"uid",t)}};return e([s()],a.prototype,"tables",null),a=e([r("esri.support.TablesMixin")],a),a};export{p as l,u as p}