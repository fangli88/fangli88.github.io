import"./p-476cf7c4.js";import{b as e,ez as t,em as s,cC as i,bw as r,b0 as o,eA as n,de as a,t as p,eB as c,d5 as l,eC as d,eD as u,bI as h,b1 as f,D as y,E as m,x as w,b9 as v,K as g,L as j,bz as b,s as S,b3 as M,aS as x,a3 as T,M as I,a4 as L,m as O,F as N}from"./p-dc4230e0.js";import{i as D,o as z,T as K}from"./p-a4de41b0.js";import{u as U}from"./p-365c5902.js";import{C as V}from"./p-76e49c46.js";import"./p-540c739d.js";import{l as $,b as A}from"./p-05aa0405.js";import"./p-f1856c76.js";import"./p-6e5ff36c.js";import{l as C,d as J}from"./p-5e52b0f8.js";import"./p-6a7ee25c.js";import{p as R}from"./p-6d77caaa.js";import{d as _}from"./p-536a38f2.js";import"./p-eb53cb9f.js";import{s as B}from"./p-3a5e7221.js";import"./p-e7885fe3.js";import"./p-8f2b0eee.js";import"./p-f66098c1.js";import{e as G,p as P}from"./p-364b7145.js";import{s as k,a as E,u as F,m as q}from"./p-ddc1853c.js";function H(h){const f=e(h)&&h.origins?h.origins:[void 0];return(y,m)=>{const w=function(d,h,f){if(e(d)&&"resource"===d.type)return function(d,u,h){const f=t(u,h);return{type:String,read:(e,t,i)=>{const r=s(e,t,i);return f.type===String?r:"function"==typeof f.type?new f.type({url:r}):void 0},write:{writer(t,s,u,y){if(!y||!y.resources)return"string"==typeof t?void(s[u]=i(t,y)):void(s[u]=t.write({},y));const m=function(e){return p(e)?null:"string"==typeof e?e:e.url}(t),w=m?i(m,{...y,verifyItemRelativeUrls:y&&y.verifyItemRelativeUrls?{writtenUrls:y.verifyItemRelativeUrls.writtenUrls,rootPath:null}:null}):null,v=f.type!==String&&(!D(this)||y&&y.origin&&this.originIdOf(h)>r(y.origin));y&&y.portalItem&&e(w)&&!o(w)?v?function(e,t,s,i,r,o,p,c){const l=p.portalItem.resourceFromPath(i),d=X(s,i,p);n(d)===a(l.path)?(W(e,t,l,d,p.resources.toUpdate),r[o]=i):Q(e,t,s,i,r,o,p,c)}(this,h,t,w,s,u,y,d):function(e,t,s,i){i.resources.toKeep.push({resource:i.portalItem.resourceFromPath(e)}),t[s]=e}(w,s,u,y):y&&y.portalItem&&(p(w)||e(c(w))||l(w)||v)?Q(this,h,t,w,s,u,y,d):s[u]=w}}}}(d,h,f);switch(e(d)&&d.type?d.type:"other"){case"other":return{read:!0,write:!0};case"url":{const{read:e,write:t}=u;return{read:e,write:t}}}}(h,y,m);for(const e of f){const t=d(y,e,m);for(const e in w)t[e]=w[e]}}}function Q(e,t,s,i,r,o,a,p){const c=z(),d=X(s,i,a),u=h(f(p,"prefix"),c),y=`${u}.${n(d)}`,m=a.portalItem.resourceFromPath(y);l(i)&&a.resources.pendingOperations.push(async function(e){const t=(await import("./p-dc4230e0.js").then((function(e){return e.eM}))).default,{data:s}=await t(e,{responseType:"blob"});return s}(i).then((e=>{m.path=`${u}.${n(e)}`,r[o]=m.itemRelativeUrl})).catch((()=>{}))),W(e,t,m,d,a.resources.toAdd),r[o]=m.itemRelativeUrl}function W(e,t,s,i,r){r.push({resource:s,content:i,finish:s=>{!function(e,t,s){"string"==typeof e[t]?e[t]=s.url:e[t].url=s.url}(e,t,s)}})}function X(e,t,s){return"string"==typeof e?{url:t}:new Blob([JSON.stringify(e.toJSON(s))],{type:"application/json"})}var Y;let Z=Y=class extends j{constructor(e){super(e),this.geometry=null,this.type="clip"}writeGeometry(e,t,s,i){if(i.layer&&i.layer.spatialReference&&!i.layer.spatialReference.equals(this.geometry.spatialReference)){if(!G(e.spatialReference,i.layer.spatialReference))return void(i&&i.messages&&i.messages.push(new b("scenemodification:unsupported","Scene modifications with incompatible spatial references are not supported",{modification:this,spatialReference:i.layer.spatialReference,context:i})));const r=new w;P(e,r,i.layer.spatialReference),t[s]=r.toJSON(i)}else t[s]=e.toJSON(i);delete t[s].spatialReference}clone(){return new Y({geometry:S(this.geometry),type:this.type})}};y([m({type:w}),H()],Z.prototype,"geometry",void 0),y([v(["web-scene","portal-item"],"geometry")],Z.prototype,"writeGeometry",null),y([m({type:["clip","mask","replace"],nonNullable:!0}),H()],Z.prototype,"type",void 0),Z=Y=y([g("esri.layers.support.SceneModification")],Z);var ee,te=Z;let se=ee=class extends(M(x.ofType(te))){constructor(e){super(e),this.url=null}toJSON(e){return this.toArray().map((t=>t.toJSON(e))).filter((e=>!!e.geometry))}clone(){return new ee({url:this.url,items:this.items.map((e=>e.clone()))})}_readModifications(e,t){for(const s of e)this.add(te.fromJSON(s,t))}static fromJSON(e,t){const s=new ee;return s._readModifications(e,t),s}static async fromUrl(e,t,s){const i={url:T(e),origin:"service"},r=await I(e,{responseType:"json",signal:f(s,"signal")}),o=t.toJSON(),n=[];for(const e of r.data)n.push(te.fromJSON({...e,geometry:{...e.geometry,spatialReference:o}},i));return new ee({url:e,items:n})}};y([m({type:String})],se.prototype,"url",void 0),se=ee=y([g("esri.layers.support.SceneModifications")],se);var ie=se;let re=class extends(K(R(C(_(B($(A))))))){constructor(...e){super(...e),this.handles=new U,this.geometryType="mesh",this.operationalLayerType="IntegratedMeshLayer",this.type="integrated-mesh",this.nodePages=null,this.materialDefinitions=null,this.textureSetDefinitions=null,this.geometryDefinitions=null,this.serviceUpdateTimeStamp=null,this.profile="mesh-pyramids",this.modifications=null,this._modificationsSource=null,this.elevationInfo=null,this.path=null}destroy(){this.handles.destroy()}initialize(){this.handles.add(V(this,"modifications","after-changes",(()=>this.modifications=this.modifications),null,null,!0))}normalizeCtorArgs(e,t){return"string"==typeof e?{url:e,...t}:e}readModifications(e,t,s){this._modificationsSource={url:L(e,s),context:s}}async load(e){return this.addResolvingPromise(this._doLoad(e)),this}async _doLoad(t){const s=f(t,"signal");try{await this.loadFromPortal({supportedTypes:["Scene Service"]},t)}catch(t){}if(await this._fetchService(s),e(this._modificationsSource)){const e=await ie.fromUrl(this._modificationsSource.url,this.spatialReference,t);this.setAtOrigin("modifications",e,this._modificationsSource.context.origin),this._modificationsSource=null}await this._verifyRootNodeAndUpdateExtent(this.nodePages,s)}beforeSave(){if(!p(this._modificationsSource))return this.load().then((()=>{}),(()=>{}))}async saveAs(e,t){return this._debouncedSaveOperations(1,{...t,getTypeKeywords:()=>this._getTypeKeywords(),portalItemLayerType:"integrated-mesh"},e)}async save(){return this._debouncedSaveOperations(0,{getTypeKeywords:()=>this._getTypeKeywords(),portalItemLayerType:"integrated-mesh"})}validateLayer(e){if(e.layerType&&"IntegratedMesh"!==e.layerType)throw new O("integrated-mesh-layer:layer-type-not-supported","IntegratedMeshLayer does not support this layer type",{layerType:e.layerType});if(isNaN(this.version.major)||isNaN(this.version.minor))throw new O("layer:service-version-not-supported","Service version is not supported.",{serviceVersion:this.version.versionString,supportedVersions:"1.x"});if(this.version.major>1)throw new O("layer:service-version-too-new","Service version is too new.",{serviceVersion:this.version.versionString,supportedVersions:"1.x"})}_getTypeKeywords(){return["IntegratedMeshLayer"]}};y([m({type:String,readOnly:!0})],re.prototype,"geometryType",void 0),y([m({type:["show","hide"]})],re.prototype,"listMode",void 0),y([m({type:["IntegratedMeshLayer"]})],re.prototype,"operationalLayerType",void 0),y([m({json:{read:!1},readOnly:!0})],re.prototype,"type",void 0),y([m({type:k,readOnly:!0})],re.prototype,"nodePages",void 0),y([m({type:[E],readOnly:!0})],re.prototype,"materialDefinitions",void 0),y([m({type:[F],readOnly:!0})],re.prototype,"textureSetDefinitions",void 0),y([m({type:[q],readOnly:!0})],re.prototype,"geometryDefinitions",void 0),y([m({readOnly:!0})],re.prototype,"serviceUpdateTimeStamp",void 0),y([m({type:ie}),H({origins:["web-scene","portal-item"],type:"resource",prefix:"modifications"})],re.prototype,"modifications",void 0),y([N(["web-scene","portal-item"],"modifications")],re.prototype,"readModifications",null),y([m(J)],re.prototype,"elevationInfo",void 0),y([m({type:String,json:{origins:{"web-scene":{read:!0,write:!0},"portal-item":{read:!0,write:!0}},read:!1}})],re.prototype,"path",void 0),re=y([g("esri.layers.IntegratedMeshLayer")],re);var oe=re;export default oe;