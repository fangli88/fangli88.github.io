import"./p-476cf7c4.js";import{l as t,w as e,cr as s,cs as i,bh as n,be as o,ct as a,bi as r,m as l,cu as c,cv as h,i as u,cw as f,b as m,ah as p,u as y,f as w,cx as d}from"./p-ab028778.js";import{o as v}from"./p-3cd8f347.js";import"./p-abda1e64.js";import"./p-a8e713de.js";import"./p-fb40af74.js";import{r as x,O as T}from"./p-4f43bb64.js";const q=t.getLogger("esri.layers.support.ElevationSampler");class g{queryElevation(t){return function(t,e){const s=E(t,e.spatialReference);if(!s)return null;switch(t.type){case"point":!function(t,e,s){t.z=s.elevationAt(e)||0}(t,s,e);break;case"polyline":!function(t,e,s){M.spatialReference=e.spatialReference;const i=t.hasM&&!t.hasZ;for(let n=0;n<t.paths.length;n++){const o=t.paths[n],a=e.paths[n];for(let t=0;t<o.length;t++){const e=o[t],n=a[t];M.x=n[0],M.y=n[1];const r=s.elevationAt(M)||0;i&&(e[3]=e[2]),e[2]=r}}t.hasZ=!0}(t,s,e);break;case"multipoint":!function(t,e,s){M.spatialReference=e.spatialReference;const i=t.hasM&&!t.hasZ;for(let n=0;n<t.points.length;n++){const o=t.points[n],a=e.points[n];M.x=a[0],M.y=a[1];const r=s.elevationAt(M)||0;i&&(o[3]=o[2]),o[2]=r}t.hasZ=!0}(t,s,e)}return t}(t.clone(),this)}on(){return A}projectIfRequired(t,e){return E(t,e)}}class _ extends g{constructor(t,e,i){super(),this.tile=t,this.noDataValue=i,this.extent=s(t.tile.extent,e.spatialReference);const n=o(e.spatialReference),a=e.lodAt(t.tile.level).resolution*n;this.demResolution={min:a,max:a}}get spatialReference(){return this.extent.spatialReference}contains(t){const e=this.projectIfRequired(t,this.spatialReference);return a(this.extent,e)}elevationAt(t){const e=this.projectIfRequired(t,this.spatialReference);if(!e)return null;if(!this.contains(t)){const e=this.extent;q.warn("#elevationAt()",`Point used to sample elevation (${t.x}, ${t.y}) is outside of the sampler extent (${e.xmin}, ${e.ymin}, ${e.xmax}, ${e.ymax})`)}return this.tile.sample(e.x,e.y)}}class b extends g{constructor(t,e,i){let n;super(),"number"==typeof e?(this.noDataValue=e,n=null):(n=e,this.noDataValue=i),this.samplers=n?t.map((t=>new _(t,n,this.noDataValue))):t;const o=this.samplers[0];if(o){this.extent=o.extent.clone();const{min:t,max:e}=o.demResolution;this.demResolution={min:t,max:e};for(let t=1;t<this.samplers.length;t++){const e=this.samplers[t];this.extent.union(e.extent),this.demResolution.min=Math.min(this.demResolution.min,e.demResolution.min),this.demResolution.max=Math.max(this.demResolution.max,e.demResolution.max)}}else this.extent=s(r(),n.spatialReference),this.demResolution={min:0,max:0}}get spatialReference(){return this.extent.spatialReference}elevationAt(t){const e=this.projectIfRequired(t,this.spatialReference);if(!e)return null;for(const t of this.samplers)if(t.contains(e))return t.elevationAt(e);return q.warn("#elevationAt()",`Point used to sample elevation (${t.x}, ${t.y}) is outside of the sampler`),null}}function E(t,e){const s=t.spatialReference;return s.equals(e)?t:i(s,e)?n(t,e):(q.error(`Cannot project geometry spatial reference (wkid:${s.wkid}) to elevation sampler spatial reference (wkid:${e.wkid})`),null)}const M=new e,A={remove(){}};class ${constructor(t,e){if(this.tile=t,!e)return void(this.samplerData=null);const s=this.tile.extent;this.samplerData={pixelData:e.values,width:e.width,height:e.height,safeWidth:.99999999*(e.width-1),noDataValue:e.noDataValue,dx:(e.width-1)/(s[2]-s[0]),dy:(e.width-1)/(s[3]-s[1]),x0:s[0],y1:s[3]}}sample(t,e){if(this.samplerData)return function(t,e,s){const{safeWidth:i,width:n,pixelData:o,noDataValue:a}=t,r=R(t.dy*(t.y1-s),0,i),l=R(t.dx*(e-t.x0),0,i),c=Math.floor(r),h=Math.floor(l),u=c*n+h,f=u+n,m=o[u],p=o[f],y=o[u+1],w=o[f+1];if(m!==a&&p!==a&&y!==a&&w!==a){const t=l-h,e=m+(y-m)*t;return e+(p+(w-p)*t-e)*(r-c)}}(this.samplerData,t,e)}}function R(t,e,s){return t<e?e:t>s?s:t}class D{async queryAll(t,e,s){if(!(t=s&&s.ignoreInvisibleLayers?t.filter((t=>t.visible)):t.slice()).length)throw new l("elevation-query:invalid-layer","Elevation queries require at least one elevation layer to fetch tiles from");const i=F.fromGeometry(e);let n=!1;s&&s.returnSampleInfo||(n=!0);const o={...k,...s,returnSampleInfo:!0},a=await this.query(t[t.length-1],i,o),r=await this._queryAllContinue(t,a,o);return r.geometry=r.geometry.export(),n&&delete r.sampleInfo,r}async query(t,e,s){if(!t)throw new l("elevation-query:invalid-layer","Elevation queries require an elevation layer to fetch tiles from");if(!e||!(e instanceof F)&&"point"!==e.type&&"multipoint"!==e.type&&"polyline"!==e.type)throw new l("elevation-query:invalid-geometry","Only point, polyline and multipoint geometries can be used to query elevation");const i={...k,...s},n=new j(t,e.spatialReference,i),o=i.signal;return await t.load({signal:o}),await this._createGeometryDescriptor(n,e,o),await this._selectTiles(n,o),await this._populateElevationTiles(n,o),this._sampleGeometryWithElevation(n),this._createQueryResult(n,o)}async createSampler(t,e,s){if(!t)throw new l("elevation-query:invalid-layer","Elevation queries require an elevation layer to fetch tiles from");if(!e||"extent"!==e.type)throw new l("elevation-query:invalid-extent","Invalid or undefined extent");const i={...k,...s};return this._createSampler(t,e,i)}async createSamplerAll(t,e,s){if(!(t=s&&s.ignoreInvisibleLayers?t.filter((t=>t.visible)):t.slice()).length)throw new l("elevation-query:invalid-layer","Elevation queries require at least one elevation layer to fetch tiles from");if(!e||"extent"!==e.type)throw new l("elevation-query:invalid-extent","Invalid or undefined extent");const i={...k,...s,returnSampleInfo:!0},n=await this._createSampler(t[t.length-1],e,i);return this._createSamplerAllContinue(t,e,n,i)}async _createSampler(t,e,s,i){const n=s.signal;await t.load({signal:n});const o=e.spatialReference,a=t.tileInfo.spatialReference;o.equals(a)||(await x([{source:o,dest:a}],{signal:n}),e=T(e,a));const r=new C(t,e,s,i);return await this._selectTiles(r,n),await this._populateElevationTiles(r,n),new b(r.elevationTiles,r.layer.tileInfo,r.options.noDataValue)}async _createSamplerAllContinue(t,e,s,i){if(t.pop(),!t.length)return s;const n=s.samplers.map((t=>c(t.extent))),o=await this._createSampler(t[t.length-1],e,i,n);if(0===o.samplers.length)return s;const a=s.samplers.concat(o.samplers),r=new b(a,i.noDataValue);return this._createSamplerAllContinue(t,e,r,i)}async _queryAllContinue(t,e,s){const i=t.pop(),n=e.geometry.coordinates,o=[],a=[];for(let s=0;s<n.length;s++){const r=e.sampleInfo[s];r.demResolution>=0?r.source||(r.source=i):t.length&&(o.push(n[s]),a.push(s))}if(!t.length||0===o.length)return e;const r=e.geometry.clone(o),l=await this.query(t[t.length-1],r,s);return a.forEach(((t,s)=>{n[t].z=l.geometry.coordinates[s].z,e.sampleInfo[t].demResolution=l.sampleInfo[s].demResolution})),this._queryAllContinue(t,e,s)}async _createQueryResult(t,e){const s={geometry:(await t.geometry.project(t.outSpatialReference,e)).export(),noDataValue:t.options.noDataValue};return t.options.returnSampleInfo&&(s.sampleInfo=this._extractSampleInfo(t)),t.geometry.coordinates.forEach((t=>{t.tile=null,t.elevationTile=null})),s}async _createGeometryDescriptor(t,e,s){let i;const n=t.layer.tileInfo.spatialReference;if(e instanceof F?i=await e.project(n,s):(await x([{source:e.spatialReference,dest:n}],{signal:s}),i=T(e,n)),!i)throw new l("elevation-query:spatial-reference-mismatch",`Cannot query elevation in '${e.spatialReference.wkid}' on an elevation service in '${n.wkid}'`);t.geometry=F.fromGeometry(i)}async _selectTiles(t,e){const s=t.options.demResolution;if("geometry"===t.type&&this._preselectOutsideLayerExtent(t),"number"==typeof s)this._selectTilesClosestResolution(t);else if("finest-contiguous"===s)await this._selectTilesFinestContiguous(t,e);else{if("auto"!==s)throw new l("elevation-query:invalid-dem-resolution",`Invalid dem resolution value '${s}', expected a number, "finest-contiguous" or "auto"`);await this._selectTilesAuto(t,e)}}_preselectOutsideLayerExtent(t){const e=new $(null);e.sample=()=>t.options.noDataValue,t.outsideExtentTile=e;const s=t.layer.fullExtent;t.geometry.coordinates.forEach((t=>{const i=t.x,n=t.y;(i<s.xmin||i>s.xmax||n<s.ymin||n>s.ymax)&&(t.elevationTile=e)}))}_selectTilesClosestResolution(t){const e=this._findNearestDemResolutionLODIndex(t.layer.tileInfo,t.options.demResolution);t.selectTilesAtLOD(e)}_findNearestDemResolutionLODIndex(t,e){const s=e/o(t.spatialReference);let i=t.lods[0],n=0;for(let e=1;e<t.lods.length;e++){const o=t.lods[e];Math.abs(o.resolution-s)<Math.abs(i.resolution-s)&&(i=o,n=e)}return n}async _selectTilesFinestContiguous(t,e){const s=S(t.layer.tileInfo,t.options.minDemResolution);await this._selectTilesFinestContiguousAt(t,s,e)}async _selectTilesFinestContiguousAt(t,e,s){const i=t.layer;if(t.selectTilesAtLOD(e),e<0)return;const n=i.tilemapCache,o=t.getTilesToFetch();try{if(n)await h(u(o.map((t=>n.fetchAvailability(t.level,t.row,t.col,{signal:s})))),s);else if(await this._populateElevationTiles(t,s),!t.allElevationTilesFetched())throw t.clearElevationTiles(),new l("elevation-query:has-unavailable-tiles")}catch(i){f(i),await this._selectTilesFinestContiguousAt(t,e-1,s)}}async _populateElevationTiles(t,e){const s=t.getTilesToFetch(),i={},n=t.options.cache,o=t.options.noDataValue,a=s.map((async s=>{const a=`${t.layer.uid}:${s.id}:${o}`,r=m(n)?n.get(a):null,l=m(r)?r:await t.layer.fetchTile(s.level,s.row,s.col,{noDataValue:o,signal:e});m(n)&&n.put(a,l),i[s.id]=new $(s,l)}));await h(p(a),e),t.populateElevationTiles(i)}async _selectTilesAuto(t,e){this._selectTilesAutoFinest(t),this._reduceTilesForMaximumRequests(t);const s=t.layer.tilemapCache;if(!s)return this._selectTilesAutoPrefetchUpsample(t,e);const i=t.getTilesToFetch(),n={},o=i.map((async t=>{const i={id:null,level:0,row:0,col:0,extent:r()},o=await v(s.fetchAvailabilityUpsample(t.level,t.row,t.col,i,{signal:e}));!1===o.ok?f(o.error):n[t.id]=i}));await h(u(o),e),t.remapTiles(n)}_reduceTilesForMaximumRequests(t){const e=t.layer.tileInfo;let s=0;const i={},n=t=>{t.id in i?i[t.id]++:(i[t.id]=1,s++)},o=t=>{const e=i[t.id];1===e?(delete i[t.id],s--):i[t.id]=e-1};t.forEachTileToFetch(n,o);let a=!0;for(;a&&(a=!1,t.forEachTileToFetch((i=>{s<=t.options.maximumAutoTileRequests||(o(i),e.upsampleTile(i)&&(a=!0),n(i))}),o),a););}_selectTilesAutoFinest(t){const e=S(t.layer.tileInfo,t.options.minDemResolution);t.selectTilesAtLOD(e,t.options.maximumAutoTileRequests)}async _selectTilesAutoPrefetchUpsample(t,e){const s=t.layer.tileInfo;await this._populateElevationTiles(t,e);let i=!1;t.forEachTileToFetch(((t,e)=>{s.upsampleTile(t)?i=!0:e()})),i&&await this._selectTilesAutoPrefetchUpsample(t,e)}_sampleGeometryWithElevation(t){t.geometry.coordinates.forEach((e=>{const s=e.elevationTile;let i=t.options.noDataValue;if(s){const t=s.sample(e.x,e.y);void 0!==t?i=t:e.elevationTile=null}e.z=i}))}_extractSampleInfo(t){const e=t.layer.tileInfo,s=o(e.spatialReference);return t.geometry.coordinates.map((i=>{let n=-1;return i.elevationTile&&i.elevationTile!==t.outsideExtentTile&&(n=e.lodAt(i.elevationTile.tile.level).resolution*s),{demResolution:n}}))}}class F{export(){return this._exporter(this.coordinates,this.spatialReference)}clone(t){const e=new F;return e.geometry=this.geometry,e.spatialReference=this.spatialReference,e.coordinates=t||this.coordinates.map((t=>this._cloneCoordinate(t))),e._exporter=this._exporter,e}async project(t,e){if(this.spatialReference.equals(t))return this.clone();await x([{source:this.spatialReference,dest:t}],{signal:e});const s=new y({spatialReference:this.spatialReference,points:this.coordinates.map((t=>[t.x,t.y]))}),i=T(s,t);if(!i)return null;const n=this.coordinates.map(((t,e)=>{const s=this._cloneCoordinate(t),n=i.points[e];return s.x=n[0],s.y=n[1],s})),o=this.clone(n);return o.spatialReference=t,o}_cloneCoordinate(t){return{x:t.x,y:t.y,z:t.z,m:t.m,tile:null,elevationTile:null}}static fromGeometry(t){const s=new F;if(s.geometry=t,s.spatialReference=t.spatialReference,t instanceof F)s.coordinates=t.coordinates.map((t=>s._cloneCoordinate(t))),s._exporter=(e,s)=>{const i=t.clone(e);return i.spatialReference=s,i};else switch(t.type){case"point":{const i=t,{hasZ:n,hasM:o}=i;s.coordinates=n&&o?[{x:i.x,y:i.y,z:i.z,m:i.m}]:n?[{x:i.x,y:i.y,z:i.z}]:o?[{x:i.x,y:i.y,m:i.m}]:[{x:i.x,y:i.y}],s._exporter=(s,i)=>t.hasM?new e(s[0].x,s[0].y,s[0].z,s[0].m,i):new e(s[0].x,s[0].y,s[0].z,i);break}case"multipoint":{const e=t,{hasZ:i,hasM:n}=e;s.coordinates=e.points.map(i&&n?t=>({x:t[0],y:t[1],z:t[2],m:t[3]}):i?t=>({x:t[0],y:t[1],z:t[2]}):n?t=>({x:t[0],y:t[1],m:t[2]}):t=>({x:t[0],y:t[1]})),s._exporter=(e,s)=>t.hasM?new y({points:e.map((t=>[t.x,t.y,t.z,t.m])),hasZ:!0,hasM:!0,spatiaReference:s}):new y(e.map((t=>[t.x,t.y,t.z])),s);break}case"polyline":{const e=t,i=[],n=[],{hasZ:o,hasM:a}=t;let r=0;for(const t of e.paths)if(n.push([r,r+t.length]),r+=t.length,o&&a)for(const e of t)i.push({x:e[0],y:e[1],z:e[2],m:e[3]});else if(o)for(const e of t)i.push({x:e[0],y:e[1],z:e[2]});else if(a)for(const e of t)i.push({x:e[0],y:e[1],m:e[2]});else for(const e of t)i.push({x:e[0],y:e[1]});s.coordinates=i,s._exporter=(e,s)=>{const i=e.map(t.hasM?t=>[t.x,t.y,t.z,t.m]:t=>[t.x,t.y,t.z]),o=n.map((t=>i.slice(t[0],t[1])));return new w({paths:o,hasM:t.hasM,hasZ:!0,spatialReference:s})};break}}return s}}class I{constructor(t,e){this.layer=t,this.options=e}}class j extends I{constructor(t,e,s){super(t,s),this.type="geometry",this.outSpatialReference=e}selectTilesAtLOD(t){if(t<0)this.geometry.coordinates.forEach((t=>t.tile=null));else{const e=this.layer.tileInfo,s=e.lods[t].level;this.geometry.coordinates.forEach((t=>{t.tile=e.tileAt(s,t.x,t.y)}))}}allElevationTilesFetched(){return!this.geometry.coordinates.some((t=>!t.elevationTile))}clearElevationTiles(){for(const t of this.geometry.coordinates)t.elevationTile!==this.outsideExtentTile&&(t.elevationTile=null)}populateElevationTiles(t){for(const e of this.geometry.coordinates)!e.elevationTile&&e.tile&&(e.elevationTile=t[e.tile.id])}remapTiles(t){for(const e of this.geometry.coordinates)e.tile=t[e.tile.id]}getTilesToFetch(){const t={},e=[];for(const s of this.geometry.coordinates){const i=s.tile;s.elevationTile||!s.tile||t[i.id]||(t[i.id]=i,e.push(i))}return e}forEachTileToFetch(t){for(const e of this.geometry.coordinates)e.tile&&!e.elevationTile&&t(e.tile,(()=>e.tile=null))}}class C extends I{constructor(t,e,s,i){super(t,s),this.type="extent",this.elevationTiles=[],this.candidateTiles=[],this.fetchedCandidates=new Set,this.extent=e.intersection(t.fullExtent),this.maskExtents=i}selectTilesAtLOD(t,e){const s=this._maximumLodForRequests(e),i=Math.min(s,t);i<0?this.candidateTiles.length=0:this._selectCandidateTilesCoveringExtentAt(i)}_maximumLodForRequests(t){const e=this.layer.tileInfo;if(!t)return e.lods.length-1;const s=this.extent;for(let i=e.lods.length-1;i>=0;i--){const n=e.lods[i],o=n.resolution*e.size[1];if(Math.ceil(s.width/(n.resolution*e.size[0]))*Math.ceil(s.height/o)<=t)return i}return-1}allElevationTilesFetched(){return this.candidateTiles.length===this.elevationTiles.length}clearElevationTiles(){this.elevationTiles.length=0,this.fetchedCandidates.clear()}populateElevationTiles(t){for(const e of this.candidateTiles){const s=t[e.id];s&&(this.fetchedCandidates.add(e),this.elevationTiles.push(s))}}remapTiles(t){this.candidateTiles=this._uniqueNonOverlappingTiles(this.candidateTiles.map((e=>t[e.id])))}getTilesToFetch(){return this.candidateTiles}forEachTileToFetch(t,e){const s=this.candidateTiles;this.candidateTiles=[],s.forEach((s=>{if(this.fetchedCandidates.has(s))return void(e&&e(s));let i=!1;t(s,(()=>i=!0)),i?e&&e(s):this.candidateTiles.push(s)})),this.candidateTiles=this._uniqueNonOverlappingTiles(this.candidateTiles,e)}_uniqueNonOverlappingTiles(t,e){const s={},i=[];for(const n of t)s[n.id]?e&&e(n):(s[n.id]=n,i.push(n));const n=i.sort(((t,e)=>t.level-e.level));return n.filter(((t,s)=>{for(let i=0;i<s;i++)if(d(n[i].extent,t.extent))return e&&e(t),!1;return!0}))}_selectCandidateTilesCoveringExtentAt(t){this.candidateTiles.length=0;const e=this.layer.tileInfo,s=e.lods[t],i=this.extent,n=e.tileAt(s.level,i.xmin,i.ymin),o=s.resolution*e.size[1],a=Math.ceil((i.xmax-n.extent[0])/(s.resolution*e.size[0])),r=Math.ceil((i.ymax-n.extent[1])/o);for(let t=0;t<r;t++)for(let s=0;s<a;s++){const i={id:null,level:n.level,row:n.row-t,col:n.col+s};e.updateTileInfo(i),this._tileIsMasked(i)||this.candidateTiles.push(i)}}_tileIsMasked(t){return!!this.maskExtents&&this.maskExtents.some((e=>d(e,t.extent)))}}function S(t,e){let s=t.lods.length-1;if(e>0){const i=t.lods.findIndex((t=>t.resolution<e));0===i?s=0:i>0&&(s=i-1)}return s}const k={maximumAutoTileRequests:20,noDataValue:0,returnSampleInfo:!1,demResolution:"auto",minDemResolution:0};export default D;export{D as ElevationQuery,F as GeometryDescriptor,S as getFinestLodIndex}