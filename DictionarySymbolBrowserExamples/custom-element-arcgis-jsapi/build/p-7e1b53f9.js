import{b6 as t,m as e,s as i,Z as s,l as a,b7 as n,D as l,E as r,ag as o,K as h,aj as c,b8 as u,O as m,U as f,h as p,W as v,al as d,ad as w,T as b,b9 as y,X as g,a6 as $}from"./p-ab028778.js";import{u as O}from"./p-73b795c3.js";import{d as D}from"./p-e07a8dfe.js";import{x as L}from"./p-8a0d1aa6.js";const S={type:L,json:{origins:{service:{read:{source:["tileInfo","minScale","maxScale","minLOD","maxLOD"],reader:T}}}}};function T(t,e,i,s){if(!t)return null;const{minScale:a,maxScale:n,minLOD:l,maxLOD:r}=e;if(null!=l&&null!=r)return L.fromJSON(s&&s.ignoreMinMaxLOD?t:{...t,lods:t.lods.filter((({level:t})=>null!=t&&t>=l&&t<=r))});if(0!==a&&0!==n){const e=t=>Math.round(1e4*t)/1e4,i=a?e(a):1/0,s=n?e(n):-1/0;return L.fromJSON({...t,lods:t.lods.filter((t=>{const a=e(t.scale);return a<=i&&a>=s}))})}return L.fromJSON(t)}class j{constructor(){this.location={left:0,top:0,width:0,height:0},this._allAvailability="unknown",this.byteSize=40}getAvailability(t,e){if("unknown"!==this._allAvailability)return this._allAvailability;const i=(t-this.location.top)*this.location.width+(e-this.location.left),s=i>>3,a=this._tileAvailabilityBitSet;return s<0||s>a.length?"unknown":a[s]&1<<i%8?"available":"unavailable"}_updateFromData(t){let e=!0,i=!0;const s=Math.ceil(this.location.width*this.location.height/8),a=new Uint8Array(s);let n=0;for(let s=0;s<t.length;s++){const l=s%8;t[s]?(i=!1,a[n]|=1<<l):e=!1,7===l&&++n}i?this._allAvailability="unavailable":e?this._allAvailability="available":(this._allAvailability="unknown",this._tileAvailabilityBitSet=a,this.byteSize+=a.length)}static fromDefinition(i,a){const n=i.service.request||s,{row:l,col:r,width:o,height:h}=i,c={query:{f:"json"}};return a=a?{...c,...a}:c,n(function(t){let e;if("vector-tile"===t.service.type)e=`${t.service.url}/tilemap/${t.level}/${t.row}/${t.col}/${t.width}/${t.height}`;else{const i=t.service.tileServers;e=`${i&&i.length?i[t.row%i.length]:t.service.url}/tilemap/${t.level}/${t.row}/${t.col}/${t.width}/${t.height}`}const i=t.service.query;return i&&(e=`${e}?${i}`),e}(i),a).then((t=>t.data)).catch((e=>{if(e&&e.details&&422===e.details.httpStatus)return{location:{top:l,left:r,width:o,height:h},valid:!0,data:t(o*h,0)};throw e})).then((t=>{if(t.location&&(t.location.top!==l||t.location.left!==r||t.location.width!==o||t.location.height!==h))throw new e("tilemap:location-mismatch","Tilemap response for different location than requested",{response:t,definition:{top:l,left:r,width:o,height:h}});return j.fromJSON(t)}))}static fromJSON(t){j.validateJSON(t);const e=new j;return e.location=Object.freeze(i(t.location)),e._updateFromData(t.data),Object.freeze(e)}static validateJSON(t){if(!t||!t.location)throw new e("tilemap:missing-location","Location missing from tilemap response");if(!1===t.valid)throw new e("tilemap:invalid","Tilemap response was marked as invalid");if(!t.data)throw new e("tilemap:missing-data","Data missing from tilemap response");if(!Array.isArray(t.data))throw new e("tilemap:data-mismatch","Data must be an array of numbers");if(t.data.length!==t.location.width*t.location.height)throw new e("tilemap:data-mismatch","Number of data items does not match width/height of tilemap")}}function A(t){return`${t.level}/${t.row}/${t.col}/${t.width}/${t.height}`}var k;const z=a.getLogger("esri.layers.support.TilemapCache");let x=k=class extends c{constructor(t){super(t),this._handles=new O,this._pendingTilemapRequests={},this._availableLevels={},this.levels=5,this.cacheByteSize=2097152,this.request=s,this._prefetchingEnabled=!0}initialize(){this._tilemapCache=new u(this.cacheByteSize),this._handles.add([this.watch(["layer.parsedUrl","layer.tileServers?"],(()=>this._initializeTilemapDefinition())),D(this,"layer.tileInfo.lods",(t=>this._initializeAvailableLevels(t)),!0)]),this._initializeTilemapDefinition()}destroy(){this._handles&&(this._handles.destroy(),this._handles=null)}castLevels(t){return t<=2?(z.error("Minimum levels for Tilemap is 3, but got ",t),3):t}get size(){return 1<<this.levels}fetchTilemap(t,i,s,a){if(!this._availableLevels[t])return m(new e("tilemap-cache:level-unavailable",`Level ${t} is unavailable in the service`));const n=this._tmpTilemapDefinition,l=this._tilemapFromCache(t,i,s,n);if(l)return f(l);const r=a&&a.signal;return a={...a,signal:null},p(((t,e)=>{v(r,(()=>e(d())));const i=A(n);let s=this._pendingTilemapRequests[i];if(!s){s=j.fromDefinition(n,a).then((t=>(this._tilemapCache.put(i,t,t.byteSize),t)));const t=()=>delete this._pendingTilemapRequests[i];this._pendingTilemapRequests[i]=s,s.then(t,t)}s.then(t,e)}))}getAvailability(t,e,i){if(!this._availableLevels[t])return"unavailable";const s=this._tilemapFromCache(t,e,i,this._tmpTilemapDefinition);return s?s.getAvailability(e,i):"unknown"}getAvailabilityUpsample(t,e,i,s){s.level=t,s.row=e,s.col=i;const a=this.layer.tileInfo;for(a.updateTileInfo(s);;){const t=this.getAvailability(s.level,s.row,s.col);if("unavailable"!==t)return t;if(!a.upsampleTile(s))return"unavailable"}}fetchAvailability(t,i,s,a){return this._availableLevels[t]?this.fetchTilemap(t,i,s,a).catch((t=>t)).then((a=>{if(a instanceof j){const n=a.getAvailability(i,s);return"unavailable"===n?m(new e("tile-map:tile-unavailable","Tile is not available",{level:t,row:i,col:s})):n}if(w(a))throw a;return"unknown"})):m(new e("tilemap-cache:level-unavailable",`Level ${t} is unavailable in the service`))}fetchAvailabilityUpsample(t,e,i,s,a){s.level=t,s.row=e,s.col=i;const n=this.layer.tileInfo;n.updateTileInfo(s);const l=this.fetchAvailability(t,e,i,a).catch((t=>{if(w(t))throw t;if(n.upsampleTile(s))return this.fetchAvailabilityUpsample(s.level,s.row,s.col,s);throw t}));return this._fetchAvailabilityUpsamplePrefetch(s.id,t,e,i,a,l),l}async _fetchAvailabilityUpsamplePrefetch(t,e,i,s,a,n){if(!this._prefetchingEnabled)return;const l=`prefetch-${t}`;if(this._handles.has(l))return;const r=b();n.then((()=>r.abort()),(()=>r.abort()));let o=!1;if(this._handles.add({remove(){o||(o=!0,r.abort())}},l),await y(10,r.signal).catch((()=>{})),o||(o=!0,this._handles.remove(l)),g(r))return;const h={id:t,level:e,row:i,col:s},c={...a,signal:r.signal},u=this.layer.tileInfo;for(let t=0;k._prefetches.length<k._maxPrefetch&&u.upsampleTile(h);++t){const t=this.fetchAvailability(h.level,h.row,h.col,c);k._prefetches.push(t);const e=()=>{k._prefetches.removeUnordered(t)};t.then(e,e)}}_initializeTilemapDefinition(){if(!this.layer.parsedUrl)return;const t=this.layer.parsedUrl,e=t.query;this._tilemapCache.clear(),this._tmpTilemapDefinition={service:{url:t.path,query:e?$(e):null,tileServers:this.layer.tileServers,request:this.request,type:this.layer.type},width:this.size,height:this.size,level:0,row:0,col:0}}_tilemapFromCache(t,e,i,s){s.level=t,s.row=e-e%this.size,s.col=i-i%this.size;const a=A(s);return this._tilemapCache.get(a)}_initializeAvailableLevels(t){this._availableLevels={},t&&t.forEach((t=>this._availableLevels[t.level]=!0))}get test(){const t=this;return{get prefetchingEnabled(){return t._prefetchingEnabled},set prefetchingEnabled(e){t._prefetchingEnabled=e},hasTilemap:(e,i,s)=>!!t._tilemapFromCache(e,i,s,t._tmpTilemapDefinition)}}};x._maxPrefetch=4,x._prefetches=new n({initialSize:k._maxPrefetch}),l([r({constructOnly:!0,type:Number})],x.prototype,"levels",void 0),l([o("levels")],x.prototype,"castLevels",null),l([r({readOnly:!0,dependsOn:["levels"],type:Number})],x.prototype,"size",null),l([r({constructOnly:!0,type:Number})],x.prototype,"cacheByteSize",void 0),l([r({constructOnly:!0})],x.prototype,"layer",void 0),l([r({constructOnly:!0})],x.prototype,"request",void 0),x=k=l([h("esri.layers.support.TilemapCache")],x);export{x as L,T as n,S as r}