import{p as e,a3 as t,al as n,M as s,be as o,l as r,f as i,y as c,t as f,x as a,b as l,bf as u,U as p,bg as y,bh as m,m as g,aI as h}from"./p-dc4230e0.js";async function w(o,r,i,c){const f="string"==typeof o?t(o):o,a=r[0].spatialReference,l={...c,query:{...f.query,f:"json",sr:JSON.stringify(a),target:JSON.stringify({geometryType:n(r[0]),geometries:r}),cutter:JSON.stringify(i)}},u=await s(f.path+"/cut",l),{cutIndexes:p,geometries:y=[]}=u.data;return{cutIndexes:p,geometries:y.map((t=>{const n=e(t);return n.spatialReference=a,n}))}}async function x(e,r,i){const c="string"==typeof e?t(e):e,f=r[0].spatialReference,a=n(r[0]),l={...i,query:{...c.query,f:"json",sr:f.wkid?f.wkid:JSON.stringify(f),geometries:JSON.stringify((u=r,{geometryType:n(u[0]),geometries:u.map((e=>e.toJSON()))}))}};var u;return function(e,t,n){const s=o(t);return e.map((e=>{const t=s.fromJSON(e);return t.spatialReference=n,t}))}((await s(c.path+"/simplify",l)).data,a,f)}const b=r.getLogger("esri.geometry.support.normalizeUtils"),N={102100:{maxX:20037508.342788905,minX:-20037508.342788905,plus180Line:new i({paths:[[[20037508.342788905,-20037508.342788905],[20037508.342788905,20037508.342788905]]],spatialReference:c.WebMercator}),minus180Line:new i({paths:[[[-20037508.342788905,-20037508.342788905],[-20037508.342788905,20037508.342788905]]],spatialReference:c.WebMercator})},4326:{maxX:180,minX:-180,plus180Line:new i({paths:[[[180,-180],[180,180]]],spatialReference:c.WGS84}),minus180Line:new i({paths:[[[-180,-180],[-180,180]]],spatialReference:c.WGS84})}};function R(e){return"polygon"===e.type}function J(e){return"polyline"===e[0].type}function L(e){return R(e)?e.rings:e.paths}function O(e,t){return Math.ceil((e-t)/(2*t))}function S(e,t){const n=L(e);for(const e of n)for(const n of e)n[0]+=t;return e}function M(e,t,n){if(t){const t=function(e,t){if(!(e instanceof i||e instanceof a)){const e="straightLineDensify: the input geometry is neither polyline nor polygon";throw b.error(e),new g(e)}const n=L(e),s=[];for(const e of n){const n=[];s.push(n),n.push([e[0][0],e[0][1]]);for(let s=0;s<e.length-1;s++){const o=e[s][0],r=e[s][1],i=e[s+1][0],c=e[s+1][1],f=Math.sqrt((i-o)*(i-o)+(c-r)*(c-r)),a=(c-r)/f,l=(i-o)/f,u=f/t;if(u>1){for(let e=1;e<=u-1;e++){const s=e*t;n.push([l*s+o,a*s+r])}const e=(f+Math.floor(u-1)*t)/2;n.push([l*e+o,a*e+r])}n.push([i,c])}}return R(e)?new a({rings:s,spatialReference:e.spatialReference}):new i({paths:s,spatialReference:e.spatialReference})}(e,1e6);e=y(t,!0)}return n&&(e=S(e,n)),e}function X(e,t,n){if(Array.isArray(e)){const s=e[0];if(s>t){const n=O(s,t);e[0]=s+n*(-2*t)}else if(s<n){const t=O(s,n);e[0]=s+t*(-2*n)}}else{const s=e.x;if(s>t){const n=O(s,t);e=e.clone().offset(n*(-2*t),0)}else if(s<n){const t=O(s,n);e=e.clone().offset(t*(-2*n),0)}}return e}async function d(e,t,n){if(!Array.isArray(e))return d([e],t);const s=t?t.url:h.geometryServiceUrl;let o,r,c,y,g,b,R,j,I=0;const q=[],A=[];for(const t of e)if(f(t))A.push(t);else if(o||(o=t.spatialReference,r=m(o),c=o.isWebMercator,b=c?102100:4326,y=N[b].maxX,g=N[b].minX,R=N[b].plus180Line,j=N[b].minus180Line),r)if("mesh"===t.type)A.push(t);else if("point"===t.type)A.push(X(t.clone(),y,g));else if("multipoint"===t.type){const e=t.clone();e.points=e.points.map((e=>X(e,y,g))),A.push(e)}else if("extent"===t.type){const e=t.clone()._normalize(!1,!1,r);A.push(e.rings?new a(e):e)}else if(t.extent){const e=t.extent,n=O(e.xmin,g)*(2*y);let s=0===n?t.clone():S(t.clone(),n);e.offset(n,0),e.intersects(R)&&e.xmax!==y?(I=e.xmax>I?e.xmax:I,s=M(s,c),q.push(s),A.push("cut")):e.intersects(j)&&e.xmin!==g?(I=e.xmax*(2*y)>I?e.xmax*(2*y):I,s=M(s,c,360),q.push(s),A.push("cut")):A.push(s)}else A.push(t.clone());else A.push(t);let T=O(I,y),U=-90;const v=T,z=new i;for(;T>0;){const e=360*T-180;z.addPath([[e,U],[e,-1*U]]),U*=-1,T--}if(q.length>0&&v>0){const t=function(e,t){let n=-1;for(let s=0;s<t.cutIndexes.length;s++){const o=t.cutIndexes[s],r=t.geometries[s],i=L(r);for(let e=0;e<i.length;e++){const t=i[e];t.some((n=>{if(n[0]<180)return!0;{let n=0;for(let e=0;e<t.length;e++){const s=t[e][0];n=s>n?s:n}n=Number(n.toFixed(9));const s=-360*O(n,180);for(let n=0;n<t.length;n++){const t=r.getPoint(e,n);r.setPoint(e,n,t.clone().offset(s,0))}return!0}}))}if(o===n){if("polygon"===e[0].type)for(const t of L(r))e[o]=e[o].addRing(t);else if(J(e))for(const t of L(r))e[o]=e[o].addPath(t)}else n=o,e[o]=r}return e}(q,await w(s,q,z,n)),o=[],r=[];for(let n=0;n<A.length;n++){const s=A[n];if("cut"!==s)r.push(s);else{const s=t.shift(),i=e[n];l(i)&&"polygon"===i.type&&i.rings&&i.rings.length>1&&s.rings.length>=i.rings.length?(o.push(s),r.push("simplify")):r.push(c?u(s):s)}}if(!o.length)return r;const i=await x(s,o,n),f=[];for(let e=0;e<r.length;e++){const t=r[e];f.push("simplify"!==t?t:c?u(i.shift()):i.shift())}return f}const D=[];for(let e=0;e<A.length;e++){const t=A[e];if("cut"!==t)D.push(t);else{const e=q.shift();D.push(!0===c?u(e):e)}}return p(D)}export{d as P}